# [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/description/)

> **日期**：2025-09-14
> **所用时间**：24min

## 1. 滑动窗口

本题是经典的滑动窗口问题。我们需要在`s`中找到一个最短的区间，使得该区间包含`t`中所有字符（包括重复字符）。

### 步骤详解

1. **统计`t`中每个字符的需求**  
   用哈希表`needs`统计`t`中每个字符出现的次数。

2. **滑动窗口遍历`s`**  
   用两个指针`l`和`r`表示窗口的左右边界，`r`向右扩展窗口，`l`向右收缩窗口。

3. **窗口内字符计数**  
   用哈希表`window`统计当前窗口内每个字符出现的次数。

4. **判断窗口是否满足条件**  
   当窗口内每个字符的数量都不小于`t`中对应字符的数量时，说明窗口已覆盖`t`。

5. **收缩窗口**  
   当窗口满足条件时，尝试收缩左边界`l`，去掉无用字符，直到窗口不再满足条件。每次收缩时更新最小窗口。

6. **返回结果**  
   最后返回记录的最小窗口子串。

### 复杂度分析

- 时间复杂度: $O(m+n)$, $m$为`s`的长度，$n`为`t`的长度
- 空间复杂度: $O(m+n)$

**Python3**

```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        ans, l = "", 0
        needs = Counter(t)
        less = len(needs)
        
        for r, c in enumerate(s):
            if c in t:
                needs[c] -= 1
                if needs[c] == 0:
                    less -= 1
                if less == 0:
                    while l <= r and (s[l] not in t or needs[s[l]] < 0):
                        if s[l] in t:
                            needs[s[l]] += 1
                            if needs[s[l]] == 1:
                                less += 1
                        l += 1
                    if len(ans) > r - l + 1 or ans == "":
                        ans = s[l:r+1]
        return ans
```