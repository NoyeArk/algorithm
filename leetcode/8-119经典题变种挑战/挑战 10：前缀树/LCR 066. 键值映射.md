# [LCR 066. 键值映射](https://leetcode.cn/problems/z1R5dt/description/)

> **日期**：2025-08-06
> **所用时间**：2min

## 1. 哈希表

最直接的做法是用一个哈希表（字典）存储所有的键值对。插入时直接赋值，查询时遍历所有 key，累加以 prefix 开头的 value。

复杂度分析：

- 时间复杂度：$O(n \cdot m)$，其中 $n$ 为 key 数，$m$ 为前缀长度
- 空间复杂度：$O(n \cdot m)$

**Python3**

```python
class MapSum:
    def __init__(self):
        self.mp = {}

    def insert(self, key: str, val: int) -> None:
        self.mp[key] = val

    def sum(self, prefix: str) -> int:
        return sum(self.mp[k] for k in self.mp.keys() if k.startswith(prefix))
```

## 2. 字典树

将 key 插入前缀树，每个节点维护一个 `cnt`，表示以该节点为前缀的所有 key 的 value 之和。

- 插入时，先计算 key 的增量（新值 - 旧值），然后沿 key 路径更新每个节点的 `cnt`。
- 查询时，沿 prefix 路径找到对应节点，返回其 `cnt`。

复杂度分析：

- 时间复杂度：$O(m)$，其中 $m$ 为 key 或 prefix 长度。
- 空间复杂度：$O(n \cdot m)$，其中 $n$ 为 key 数，$m$ 为前缀长度。

**Python3**

```python
class TrieNode:
    __slots__ = ['cnt', 'children']
    def __init__(self):
        self.cnt = 0
        self.children = {}

class MapSum:
    def __init__(self):
        self.root = TrieNode()
        self.mp = {}

    def insert(self, key: str, val: int) -> None:
        diff = val - self.mp.get(key, 0)
        self.mp[key] = val
        node = self.root
        for c in key:
            if c not in node.children:
                node.children[c] = TrieNode()
            node = node.children[c]
            node.cnt += diff

    def sum(self, prefix: str) -> int:
        node = self.root
        for c in prefix:
            if c not in node.children:
                return 0
            node = node.children[c]
        return node.cnt
```