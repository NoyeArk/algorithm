# [LCR 067. 数组中两个数的最大异或值](https://leetcode.cn/problems/ms70jA/description/)

> **日期**：2025-08-10
> **所用时间**：15min

## 1. 字典树

本题要求在一个整数数组中，找出两个数的最大异或值。常规做法是两两枚举，时间复杂度 $O(n^2)$，但本题数据范围较大，需要更高效的方法。

### 思路分析

#### 1. 利用前缀树（字典树）优化

异或的本质是：对于每一位，若两个数该位不同，则异或结果为1。为了让异或最大，我们希望每一位都能取到不同的值。

具体做法：

- 将所有数字按二进制位插入到前缀树（Trie）中。每个节点有两个分支，分别代表0和1。
- 对于每个数，从高位到低位在Trie中查找：每一位尽量走与当前位相反的分支（即如果当前位是0，优先走1），这样能让异或值最大。
- 记录每次查找得到的最大异或值。

#### 2. 代码实现要点

- 先确定最大数的二进制位数 $n$，Trie树深度为 $n$。
- 插入和查找都从高位到低位。
- 查找时每一位优先走相反分支，若没有则只能走相同分支。

#### 3. 例子说明

以 nums = [3, 10, 5, 25, 2, 8] 为例：

- 25 的二进制为 11001，3 的二进制为 00011。
- 25 和 5 异或为 28（11001 ^ 00101 = 11100），是最大值。

### 复杂度分析

- 时间复杂度：$O(n \cdot m)$，$n$ 为数组长度，$m$ 为最大数的二进制位数（最多32）
- 空间复杂度：$O(n \cdot m)$，Trie树最多 $n \cdot m$ 个节点

**Python3**

```python
class Trie:
    def __init__(self, n: int):
        self.son = {}
        self.n = n
    
    def insert(self, num: int):
        cur = self.son
        for i in range(self.n-1, -1, -1):
            bit = (num >> i) & 1
            if bit not in cur:
                cur[bit] = {}
            cur = cur[bit]
    
    def search(self, num: int) -> int:
        cur = self.son
        res = 0
        for i in range(self.n-1, -1, -1):
            bit = (num >> i) & 1
            tar = 1 - bit
            res <<= 1
            if tar in cur:
                res |= 1
                cur = cur[tar]
            else:
                cur = cur[bit]
        return res

class Solution:
    def findMaximumXOR(self, nums: List[int]) -> int:
        n = max(nums).bit_length()
        trie = Trie(n)
        for num in nums:
            trie.insert(num)
        return max(trie.search(num) for num in nums)
```