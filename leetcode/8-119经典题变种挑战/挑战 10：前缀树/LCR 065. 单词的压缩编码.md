# [LCR 065. 单词的压缩编码](https://leetcode.cn/problems/iSwD2y/description/)

> **日期**：2025-08-03
> **所用时间**：15min

## 1. 集合去重 + 枚举后缀

1. 首先，将所有单词放入一个集合 `goods` 中，这样可以自动去重，避免重复计算。
2. 然后，遍历每一个单词 `word`，对于该单词，枚举它所有可能的**非自身后缀**（即从第2个字符开始到最后的所有子串），例如对于 "time"，后缀有 "ime"、"me"、"e"。将这些后缀从集合 `goods` 中移除。这样做的目的是：如果某个单词是另一个单词的后缀，那么它就不需要单独编码，因为它会被包含在更长单词的编码中。
3. 最后，集合 `goods` 中剩下的单词就是需要单独编码的单词。对于每个这样的单词，编码时需要在末尾加上一个 `#`，所以总编码长度为所有剩余单词长度加上单词数（每个单词一个 `#`）。将这些长度相加即为最终答案。

复杂度分析：
- 时间复杂度: $O(n \times m)$，其中 $n$ 是字典中的词根个数，$m$ 是单词的平均长度
- 空间复杂度: $O(n \times m)$，其中 $n$ 是字典中的词根个数，$m$ 是单词的平均长度

**Python3**

```python
class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        goods = set(words)
        for word in words:
            for k in range(1, len(word)):
                goods.discard(word[k:])
        return sum(len(word) + 1 for word in goods)
```

## 2. 前缀树

本题可以用**前缀树（Trie）**来高效解决。由于题目要求如果一个单词是另一个单词的后缀，则不需要单独编码，因此我们可以将所有单词**反转**后插入前缀树。这样，原本的“后缀”就变成了“前缀”，利用前缀树的特性可以方便地合并公共后缀。

1. 去重与反转
   首先对所有单词去重（避免重复计算），然后将每个单词反转。这样，原本的后缀关系就变成了前缀关系。

2. 构建前缀树
   将每个反转后的单词插入前缀树。前缀树的每个节点用字典表示。

3. 统计编码长度
   最终只需要统计所有“叶子节点”对应的单词长度（即没有子节点的节点），每个单词编码时还要加上一个 `#`，所以总长度为 `len(word) + 1`。

复杂度分析：

- 时间复杂度：$O(Σ|word|)$，其中 $Σ|word|$ 为所有单词的长度之和。每个单词插入和遍历前缀树的复杂度均为 $O(m)$。
- 空间复杂度：$O(26 \times Σ|word|)$，前缀树最多存储所有单词的所有字符。

**Python3**

```python
class Trie:
    def __init__(self):
        self.son = {}
    
    def insert(self, word):
        cur = self.son
        for c in word:
            if c not in cur:
                cur[c] = {}
            cur = cur[c]
    

class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        tree = Trie()
        for word in words:
            tree.insert(word[::-1])

        ans = 0
        def dfs(root, level):
            if not root:
                nonlocal ans
                ans += level + 1
                return
            for node in root.values():
                dfs(node, level + 1)
        dfs(tree.son, 0)
        return ans
```

## 3. 字典树简洁实现

上述代码实现了单词压缩编码问题的字典树（前缀树）简洁写法，具体解释如下：

1. `Trie = lambda: collections.defaultdict(Trie)`  
   这里用一个 lambda 表达式递归地定义了 Trie（字典树）节点，每个节点是一个 defaultdict，遇到不存在的 key 会自动创建子节点。这样可以非常简洁地构建多叉树结构。

2. `trie = Trie()`  
   初始化一个空的字典树根节点。

3. `words = list(set(words))`  
   先对输入的单词去重，避免重复计算。

4. `nodes = [reduce(dict.__getitem__, word[::-1], trie) for word in words]`  
   对每个单词反转（因为题目要求统计所有不是其他单词后缀的单词），然后用 reduce 依次在 trie 中查找/创建每个字符的节点，最终 nodes 里保存了每个单词插入后对应的最后一个节点。

5. `return sum(len(word) + 1 for i, word in enumerate(words) if len(nodes[i]) == 0)`  
   遍历所有单词，如果该单词对应的节点没有子节点（即为叶子节点，说明没有其他单词以它为后缀），则将其长度加 1（加上 `#`），累加得到最终编码长度。

这种写法利用了 Python 的高阶函数和 defaultdict 的特性，使得代码非常简洁，省去了显式定义 TrieNode 类和递归遍历的过程。


**Python3**

```python
class Solution:
    def minimumLengthEncoding(self, words: List[str]) -> int:
        Trie = lambda: collections.defaultdict(Trie)
        trie = Trie()

        words = list(set(words))
        nodes = [reduce(dict.__getitem__, word[::-1], trie) for word in words]
        return sum(len(word) + 1 for i, word in enumerate(words) if len(nodes[i]) == 0)
```