# [LCR 064. 实现一个魔法字典](https://leetcode.cn/problems/US1pGT/description/)

> **日期**：2025-08-10
> **所用时间**：20min

## 1. 字典树

用字典树存储所有单词，便于高效查找和遍历。每个节点用 `son` 字典存储子节点，`is_end` 标记是否为单词结尾。

这里在遍历字典树的时候分为两种情况：

1. 第一种情况：当前字符与字典树节点的字符相同。由于题目要求必须修改一个字符，所以可以判断当前字符是否有可以不匹配的节点，如果有，则判断该不匹配的节点后面的字符是否可以匹配，如果可以返回 True。

2. 第二种情况：当前字符与字典树节点的字符不同。此时我们尝试将当前字符修改为字典树节点的字符（即“只允许修改一次”），然后递归判断剩余的字符能否与字典树的后续分支完全匹配，并且只能修改这一次。如果能走到字典树的单词结尾且只修改了一次字符，则返回 True。

复杂度分析：

- 建树复杂度：$O(\sum |word|)$，$|word|$ 为所有单词长度之和。
- 查询复杂度：最坏 $O(26^k \cdot k)$，$k$ 为单词长度，但实际分支远小于 $26^k$，效率较高。

**Python3**

```python
class Node:
    def __init__(self):
        self.son = {}
        self.is_end = False

class MagicDictionary:
    def __init__(self):
        self.root = Node()

    def buildDict(self, dictionary: List[str]) -> None:
        for word in dictionary:
            cur = self.root
            for c in word:
                if c not in cur.son:
                    cur.son[c] = Node()
                cur = cur.son[c]
            cur.is_end = True

    def search(self, searchWord: str) -> bool:
        def dfs(cur, word):
            for c in word:
                if c not in cur.son:
                    return False
                cur = cur.son[c]
            return cur.is_end

        cur = self.root
        for i, c in enumerate(searchWord):
            if c not in cur.son:
                return any(dfs(v, searchWord[i+1:]) for v in cur.son.values())
            for k, v in cur.son.items():
                if k != c and dfs(v, searchWord[i+1:]):
                    return True
            cur = cur.son[c]
        return False
```