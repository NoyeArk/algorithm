# [LCR 092. 将字符串翻转到单调递增](https://leetcode.cn/problems/cyJERH/description/)

> **日期**：2025-02-01
> **所用时间**：11min

## 1. 动态规划

### 状态表示

- $f[i][0]$ 表示前 $i$ 个字符构成的子串，以 $0$ 结尾的单调递增子串的个数
- $f[i][1]$ 表示前 $i$ 个字符构成的子串，以 $1$ 结尾的单调递增子串的个数

### 状态转移

- 如果 $s[i] = '0'$ ：
  - $f[i][0]$ 只能接在 $f[i - 1][0]$ 的子串后面，所以 $f[i][0] = f[i - 1][0]$
  - $f[i][1]$ 可以接在 $f[i - 1][0]$ 的子串后面，也可以接在 $f[i - 1][1]$ 的子串后面，所以 $f[i][1] = \min(f[i - 1]) + 1$ ，加 $1$ 表示将 $s[i]$ 翻转到 $1$
- 如果 $s[i] = '1'$ ：
  - $f[i][0]$ 只能接在 $f[i - 1][0]$ 的子串后面，所以 $f[i][0] = f[i - 1][0] + 1$
  - $f[i][1]$ 可以接在 $f[i - 1][0]$ 的子串后面，也可以接在 $f[i - 1][1]$ 的子串后面，所以 $f[i][1] = \min(f[i - 1])$
  
### 初始化

如果 $s[0] = '0'$ ，则 $f[0][0] = 0$ ，$f[0][1] = 1$ ，表示前 $0$ 个字符构成的子串，以 $0$ 结尾的单调递增子串的个数为 $0$，以 $1$ 结尾的单调递增子串的个数为 $1$

否则，$f[0][0] = 1$ ，$f[0][1] = 0$ ，表示前 $0$ 个字符构成的子串，以 $0$ 结尾的单调递增子串的个数为 $1$，以 $1$ 结尾的单调递增子串的个数为 $0$

### 复杂度分析

- 时间复杂度: $O(n)$
- 空间复杂度: $O(n)$

**Python3**

```python
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        f = [[0, 0] for _ in range(n)]
        f[0][0], f[0][1] = int(s[0] != '0'), 1 - f[0][0]
        
        for i in range(1, n):
            if s[i] == '0':
                f[i][0] = f[i - 1][0]
                f[i][1] = min(f[i - 1]) + 1
            else:
                f[i][0] = f[i - 1][0] + 1
                f[i][1] = min(f[i - 1])
        return min(f[n - 1])
```

## 2. 空间优化

通过上述状态计算方程，可以发现 $f[i][0]$ 和 $f[i][1]$ 只与 $f[i - 1][0]$ 和 $f[i - 1][1]$ 有关，所以可以进行状态压缩，将二维数组压缩为一维数组。

- 时间复杂度: $O(n)$
- 空间复杂度: $O(1)$

**Python3**

```python
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        f = [0, 0]
        
        for i in range(n):
            t = f.copy()
            if s[i] == '0':
                f[0] = t[0]
                f[1] = min(t) + 1
            else:
                f[0] = t[0] + 1
                f[1] = min(t)
        return min(f)
```

## 3. 状态计算合并

在上面的状态计算中，需要对 $s[i] = '0'$ 和 $s[i] = '1'$ 的情况分别进行讨论，实际上可以合并为一种情况，即：

$$
    f[0] = t[0] + int(s[i] != '0')
$$

$$
    f[1] = \min(t) + int(s[i] != '1')
$$

- 时间复杂度: $O(n)$
- 空间复杂度: $O(1)$

**Python3**

```python
class Solution:
    def minFlipsMonoIncr(self, s: str) -> int:
        n = len(s)
        f = [0, 0]
        for i in range(n):
            t = f[::]
            f[0] = t[0] + int(s[i] != '0')
            f[1] = min(t) + int(s[i] != '1')
        return min(f)
```

