# [LCR 105. 粉刷房子](https://leetcode.cn/problems/ZL6zAn/description/)

> **日期**：2025-07-12
> **所用时间**：10min

## 1. 图的深度优先遍历

本题考查的是图的深度优先遍历（DFS）在网格类问题中的应用。题目要求我们找到二维网格中“岛屿”的最大面积。岛屿由相邻的1组成（上下左右四个方向），面积即为岛屿中1的个数。

### 解题思路

1. **遍历网格**：我们需要遍历整个网格的每一个单元格。
2. **遇到陆地（1）且未访问过时，启动DFS**：每当遇到一个未访问过的1，就以它为起点，进行深度优先遍历，把与它连通的所有1都访问一遍，并统计连通块的面积。
3. **DFS实现**：DFS递归地访问上下左右四个方向的相邻单元格，只要是1且未访问过就继续递归，并累计面积。
4. **记录最大面积**：每次DFS返回的面积与当前最大面积比较，更新最大值。

### 关键细节

- 需要一个`vis`集合或字典来记录哪些格子已经访问过，避免重复遍历。
- 递归时要注意边界条件，防止越界。
- 每次DFS返回的是当前岛屿的面积。

### 复杂度分析

- 时间复杂度: $O(n^2)$
- 空间复杂度: $O(n^2)$

**Python3**

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        def dfs(i, j):
            if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:
                return 0
            grid[i][j] = 0
            res = 1
            for dx, dy in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                x, y = i + dx, j + dy
                res += dfs(x, y)
            return res
        return max(dfs(i, j) for i in range(m) for j in range(n))
```