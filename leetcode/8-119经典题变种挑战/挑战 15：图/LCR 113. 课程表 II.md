# [LCR 113. 课程表 II](https://leetcode.cn/problems/QA2IGt/description/)

> **日期**：2025-08-14
> **所用时间**：15min

## 1. 拓扑排序

用邻接表 `g` 存储图结构，`g[b]` 里存放所有依赖于课程 b 的课程 a。用数组 `d` 统计每门课的入度（即有多少前置课程）。

拓扑排序（BFS/Kahn算法）：

1. 首先将所有入度为 0 的课程加入队列 `q`，这些课程可以直接学习。
2. 不断从队列中取出课程 i，加入答案列表 `ans`，并将所有依赖于 i 的课程 j 的入度减 1。
3. 如果某个课程 j 的入度变为 0，说明它的所有前置课程都已学完，可以加入队列。
4. 最后如果能遍历完所有课程（即 `ans` 长度等于课程总数），则返回顺序，否则返回空数组（说明有环，无法完成所有课程）。

由于题目要求返回任意一种可行顺序，所以 BFS 顺序即可。若有环（即存在课程无法入队），则无法完成所有课程。

复杂度分析：

- 时间复杂度：$O(n + m)$，其中 $n$ 为节点数，$m$ 为边数
- 空间复杂度：$O(n)$，队列和邻接表存储。

**Python3**

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        d = [0] * numCourses
        g = [[] for _ in range(numCourses)]

        for a, b in prerequisites:
            g[b].append(a)
            d[a] += 1

        q = []
        for i in range(numCourses):
            if d[i] == 0:
                q.append(i)

        ans = []
        while q:
            i = q.pop(0)
            ans.append(i)
            for j in g[i]:
                d[j] -= 1
                if d[j] == 0:
                    q.append(j)
        return ans if len(ans) == numCourses else []
```