# [LCR 118. 冗余连接](https://leetcode.cn/problems/D0F0SV/description/)

> **日期**：2025-08-21
> **所用时间**：10min

## 1. 并查集

### 题目描述

给定一个无向图，该图最初是一个树（即有 $n$ 个节点和 $n-1$ 条边的连通无环图），后来又多了一条边，导致图中出现了环。请找出这条多余的边（即移除后图恢复为树）。如果有多个答案，返回输入顺序最后出现的那条边。

### 解题思路

本题本质是**无向图的环检测**，最常用的方法是**并查集（Disjoint Set Union, DSU）**。并查集适合处理连通性问题，能够高效判断两个节点是否属于同一连通分量。

#### 1. 并查集原理

- 每个节点初始自成一个集合（父节点指向自己）。
- 遍历每条边 $(a, b)$：
    - 查询 $a$ 和 $b$ 的根节点（find 操作）。
    - 如果根节点不同，说明 $a$ 和 $b$ 不连通，可以合并（union 操作）。
    - 如果根节点相同，说明 $a$ 和 $b$ 已经连通，再次连接会形成环，这条边即为多余的边。

#### 2. 代码实现要点

- 用一个数组 `pre` 记录每个节点的父节点。
- `find` 函数递归查找根节点（可加路径压缩优化）。
- 遍历所有边，依次执行上述操作，遇到成环的边即返回。

#### 3. 复杂度分析

- 时间复杂度：$O(n\log n)$，每次查找和合并操作均摊为对数级别。
- 空间复杂度：$O(n)$，用于存储并查集数组。

**Python3**

```python
class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        pre = list(range(len(edges)))
        def find(i):
            if pre[i] == i:
                return i
            return find(pre[i])
    
        for a, b in edges:
            i, j = find(a - 1), find(b - 1)
            if i != j:
                pre[j] = i
            else:
                ans = [a, b]
        return ans
```