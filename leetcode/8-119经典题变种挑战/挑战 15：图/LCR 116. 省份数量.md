# [LCR 116. 省份数量](https://leetcode.cn/problems/bLyHh0/description/)

> **日期**：2025-08-21
> **所用时间**：10min

## 1. 深度优先搜索

给定一个 $n \times n$ 的矩阵 `isConnected`，其中 `isConnected[i][j] = 1` 表示第 $i$ 个城市和第 $j$ 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。

返回矩阵中省份的数量。

代码流程：

1. 遍历矩阵，构建邻接表 `g`。
2. 初始化一个数组 `vis` 记录每个城市的访问状态。
3. 遍历每个城市，若未访问过，则进行深度优先搜索，标记所有与之连通的城市。
4. 统计深度优先搜索的次数，即为省份数量。

复杂度分析：

- 时间复杂度：$O(n^2)$，每个城市最多访问一次。
- 空间复杂度：$O(n)$，邻接表和访问数组。

**Python3**

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        n = len(isConnected)
        g = [[] for _ in range(n)]
        for i in range(n):
            for j in range(n):
                if isConnected[i][j] == 1 and i != j:
                    g[i].append(j)

        vis = [False] * n
        def dfs(node: int):
            vis[node] = True
            for neighbor in g[node]:
                if not vis[neighbor]:
                    dfs(neighbor)

        provinces = 0
        for i in range(n):
            if not vis[i]:
                provinces += 1
                dfs(i)
        
        return provinces
```

## 2. 并查集

使用并查集，将每个城市看作一个节点，若两个城市直接相连，则将两个节点合并。

1. 初始化一个数组 `fa` 记录每个城市的父节点。
2. 遍历矩阵，若两个城市直接相连，则将两个城市合并。
3. 统计 `fa` 数组中，父节点为自身的城市数量，即为省份数量。

复杂度分析：

- 时间复杂度：$O(n^2\log n)$，每个城市最多访问一次。
- 空间复杂度：$O(n)$，并查集数组。

**Python3**

```python
class Solution:
    def findCircleNum(self, isConnected: List[List[int]]) -> int:
        def find(i):
            if fa[i] != i:
                fa[i] = find(fa[i])
            return fa[i]
        
        def union(i, j):
            fa[find(i)] = find(j)
        
        n = len(isConnected)
        fa = list(range(n))
        for i in range(n):
            for j in range(i + 1, n):
                if isConnected[i][j] == 1:
                    union(i, j)
        return sum(fa[i] == i for i in range(n))
```