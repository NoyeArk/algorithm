# [LCR 115. 序列重建](https://leetcode.cn/problems/ur2n8P/description/)

> **日期**：2025-08-16
> **所用时间**：10min

## 1. 拓扑排序

给定一个长度为 $n$ 的整数序列 `nums`，以及若干子序列 `sequences`，每个子序列都是 `nums` 的一个子序列。请判断是否**唯一**可以通过这些子序列还原出原始序列 `nums`。

换句话说，能否根据所有子序列的相对顺序关系，唯一确定出原始序列。

用邻接表 `g` 存储图结构，用数组 `d` 统计每个节点的入度。

由于题目要求返回任意一种可行顺序，所以 BFS 顺序即可。若有环（即存在节点无法入队），则无法完成所有节点。

代码流程：

1. 遍历所有子序列，统计每个节点的入度和出边。
2. 初始化队列，加入所有入度为 $0$ 的节点。
3. 每次从队列弹出一个节点，若队列长度大于 $1$，说明当前有多个选择，返回 `False`。
4. 遍历该节点的所有出边，更新入度，若入度为 $0$ 则加入队列。
5. 最终如果所有节点都被唯一确定，返回 `True`，否则返回 `False`。

复杂度分析：

- 时间复杂度：$O(n + m)$，其中 $n$ 为节点数，$m$ 为所有子序列长度之和。
- 空间复杂度：$O(n + m)$，邻接表和入度数组的存储。

**Python3**

```python
class Solution:
    def sequenceReconstruction(self, nums: List[int], sequences: List[List[int]]) -> bool:
        n = len(nums)
        d = [0] * (n + 1)
        g = [[] for _ in range(n + 1)]

        for seq in sequences:
            for a, b in pairwise(seq):
                d[b] += 1
                g[a].append(b)

        q = [i for i in range(1, n + 1) if d[i] == 0]
        while q:
            if len(q) > 1:
                return False
            i = q.pop()
            for j in g[i]:
                d[j] -= 1
                if d[j] == 0:
                    q.append(j)
        return True
```