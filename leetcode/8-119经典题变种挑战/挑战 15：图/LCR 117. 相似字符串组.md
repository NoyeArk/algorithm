# [LCR 117. 相似字符串组](https://leetcode.cn/problems/H6lPxb/description/)

> **日期**：2025-09-13
> **所用时间**：13min

## 1. 深度优先搜索

### 解题思路

#### 1. 建模为图的连通分量问题

- 每个字符串看作图中的一个节点。
- 如果两个字符串相似（即恰好有两个字符不同），就在它们之间连一条边。
- 问题转化为：图中有多少个连通分量。

#### 2. 判断字符串是否相似

- 遍历两个字符串，统计不同字符的位置数。
- 只有当不同字符数为0或2时，才认为它们相似（0表示完全相同，2表示可以通过一次交换变成对方）。

#### 3. 构建图

- 用邻接表存储图结构。
- 两重循环枚举所有字符串对，判断是否相似，相似则互为邻居。

#### 4. 深度优先搜索（DFS）统计连通分量

- 用集合 `st` 记录已访问的字符串。
- 对每个未访问的字符串，进行一次DFS，遍历所有与之连通的字符串，并计数。

### 代码流程

1. 构建邻接表 `g`，将所有相似的字符串连边。
2. 用集合 `st` 记录访问过的字符串。
3. 对每个字符串，若未访问，则以其为起点DFS，计数器加一。
4. 返回计数器即为分组数。

### 复杂度分析

- 时间复杂度：$O(n^2 m)$，其中 $n$ 为字符串数量，$m$ 为字符串长度。两重循环判断相似性，每次比较需要 $O(m)$。
- 空间复杂度：$O(n^2)$，邻接表存储所有可能的边，最坏情况下完全图。


**Python3**

```python
class Solution:
    def numSimilarGroups(self, strs: List[str]) -> int:
        n = len(strs)
        g = defaultdict(list)

        for i in range(n):
            for j in range(i + 1, n):
                s1, s2 = strs[i], strs[j]
                cnt = 0
                for k in range(len(s1)):
                    if s1[k] != s2[k]:
                        cnt += 1
                if cnt > 2:
                    continue
                g[s1].append(s2)
                g[s2].append(s1)

        def dfs(s):
            st.add(s)
            for ne in g[s]:
                if ne not in st and ne != s:
                    dfs(ne)

        ans = 0
        st = set()
        for s in strs:
            if s not in st:
                ans += 1
                dfs(s)
        return ans
```