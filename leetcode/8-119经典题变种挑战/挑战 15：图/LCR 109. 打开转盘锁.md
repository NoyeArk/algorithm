# [LCR 109. 打开转盘锁](https://leetcode.cn/problems/zlDJc7/)

> **日期**：2025-08-24
> **所用时间**：30min

## 1. 广度优先搜索

本题可以建模为**无权图的最短路径问题**。每个密码状态是一个节点，相邻节点之间可以通过拨动某一位到达。死亡密码相当于“障碍”，不能经过。

为什么用 BFS？

- 每次拨动的代价相同，BFS 能保证第一次到达目标时就是最短路径。
- BFS 能有效避免重复状态和死循环。

具体实现：

- 用队列 `q` 存储当前所有待扩展的状态和步数。
- 用集合 `vis` 记录已经访问过的状态，避免重复。
- 每次从队列取出一个状态，尝试拨动每一位（向上和向下），生成新状态。
- 如果新状态等于目标，返回步数。
- 如果新状态不是死亡密码且未访问过，加入队列和访问集合。
- 如果队列为空还没找到目标，返回 -1。

复杂度分析：

- 时间复杂度：$O(b^2 \times d^2 + md)$，b 为每个转轮的数字个数，d 为转轮个数，m 为死亡密码个数。
- 空间复杂度：$O(b^2 \times d^2 + m)$，用于队列和访问集合。

代码详解：

- `get_next(num)`：生成当前状态所有可能的下一步状态。
- 先判断特殊情况：目标就是 "0000" 直接返回 0，"0000" 是死亡密码直接返回 -1。
- BFS 主循环，每次扩展当前状态的所有下一步。
- 找到目标立即返回步数，否则最终返回 -1。

**Python3**

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        def get_next(num):
            for pos, c in enumerate(num):
                i = int(c)
                j = (i + 1) % 10
                yield num[:pos] + str(j) + num[pos+1:]
                k = (i - 1 + 10) % 10
                yield num[:pos] + str(k) + num[pos+1:]

        if target == "0000":
            return 0
        if "0000" in deadends:
            return -1
    
        q = [('0000', 0)]
        vis = {'0000'}
        while q:
            num, dist = q.pop(0)
            for i in get_next(num):
                if i not in deadends and i not in vis:
                    if i == target:
                        return dist + 1
                    q.append((i, dist + 1))
                    vis.add(i)
        return -1
```