# [LCR 114. 火星词典](https://leetcode.cn/problems/Jf1JuT/description/)

> **日期**：2025-08-23
> **所用时间**：23min

## 1. 拓扑排序

本题考查**拓扑排序**在字典序推断中的应用。题目给定一个火星词典的单词列表，要求推断出火星字母的先后顺序（即字典序规则）。如果无法确定唯一顺序或存在矛盾（如环），则返回空字符串。

### 解题思路

1. **建图**  
   - 首先统计所有出现过的字母，建立字母集合。
   - 用邻接表 `g` 存储字母之间的先后关系（有向边），用入度数组 `d` 记录每个字母被指向的次数。
   - 遍历相邻的单词对，找到第一个不同的字母，假设为 `a[i]` 和 `b[i]`，则有 `a[i]` 必须排在 `b[i]` 前面，建立有向边 `a[i] -> b[i]`，并将 `b[i]` 的入度加一。
   - 特判：如果前一个单词是后一个单词的前缀且更长，则无解，直接返回空字符串。

2. **拓扑排序**  
   - 将所有入度为 0 的字母加入队列，依次弹出，加入答案字符串。
   - 每弹出一个字母，就将其指向的字母入度减一，若入度变为 0，则加入队列。
   - 若过程中出现环（即某些字母无法入队），或有重复访问，返回空字符串。

3. **输出结果**  
   - 若最终答案长度等于字母总数，说明排序成功，返回答案；否则返回空字符串。

### 关键点

- 拓扑排序用于解决有向无环图（DAG）中的先后依赖关系。
- 本题的难点在于如何根据单词列表推断字母之间的有向边。
- 注意前缀特判和环的检测。

### 代码简析

- `letter` 统计所有字母，`chr2idx`/`idx2chr` 实现字母与编号的映射。
- `g` 为邻接表，`d` 为入度数组。
- `pairwise(words)` 遍历相邻单词对，推断字母先后关系。
- 队列 `q` 实现 BFS 拓扑排序，`ans` 记录结果。
- 若排序过程中发现环或有字母未被排序，返回空字符串。

本题与经典的课程表 II（LCR 113）类似，都是通过拓扑排序解决依赖关系，只不过本题的节点是字母，依赖关系由单词顺序推断而来。

复杂度分析：

- 时间复杂度：$O(n + m)$，其中 $n$ 为节点数，$m$ 为边数
- 空间复杂度：$O(n)$，队列和邻接表存储。

**Python3**

```python
class Solution:
    def alienOrder(self, words: List[str]) -> str:
        letter = set(''.join(words))
        n = len(letter)
        chr2idx = {c: i for i, c in enumerate(list(letter))}
        idx2chr = {i: c for i, c in enumerate(list(letter))}

        d = [0] * n
        g = [[] for _ in range(n)]
        for a, b in pairwise(words):
            i = 0
            while i < min(len(a), len(b)) and a[i] == b[i]:
                i += 1
            if i == len(a):
                continue
            elif i == len(b):
                return ""
            d[chr2idx[b[i]]] += 1
            g[chr2idx[a[i]]].append(chr2idx[b[i]])

        ans = ""
        vis = {}
        q = [i for i in range(n) if d[i] == 0]
        while q:
            i = q.pop(0)
            ans += idx2chr[i]
            for j in g[i]:
                d[j] -= 1
                if d[j] == 0:
                    q.append(j)
        return ans if len(ans) == n else ""
```