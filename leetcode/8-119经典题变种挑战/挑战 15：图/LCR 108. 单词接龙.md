# [LCR 108. 单词接龙](https://leetcode.cn/problems/om3reC/description/)

> **日期**：2025-07-28
> **所用时间**：56min

## 1. 单向 BFS

### 题目描述

给定两个单词 `beginWord` 和 `endWord`，以及一个字典 `wordList`，请找出从 `beginWord` 到 `endWord` 的最短转换序列的长度。每次转换只能改变一个字母，且转换后的单词必须在字典中。若无法转换，返回 0。

### 解题思路

#### 1. 问题本质

本题本质是**无权图的最短路径问题**，每个单词看作一个节点，若两个单词只差一个字母，则它们之间有一条边。要求从 `beginWord` 到 `endWord` 的最短路径长度。

#### 2. 为什么用 BFS？

- 因为每次变换的代价相同，BFS 能保证第一次到达终点时就是最短路径。
- 但如果直接单向 BFS，可能会超时（字典很大，分支多）。

#### 3. 双向 BFS 优化

- 从起点和终点同时扩展，每次选择节点数较少的一侧扩展，可以大大减少搜索空间。
- 只要两侧有交集，即可得到最短路径。

#### 4. 具体实现

- 用两个集合 `begin_set` 和 `end_set` 分别表示从起点和终点出发的当前层节点。
- 每次扩展 begin_set，如果 begin_set 大于 end_set，则交换两者，始终扩展较小集合。
- 对于每个单词，尝试替换每一位为 26 个小写字母，若新单词在另一侧集合中，说明找到路径。
- 用 `visited` 集合避免重复访问。

#### 5. 复杂度分析

- 时间复杂度：$O(N \times L^2)$，N 为单词数，L 为单词长度
- 空间复杂度：$O(N \times L)$

**Python3**

```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0

        def get_next(word):
            res = []
            for i, c in enumerate(word):
                for ch in ascii_lowercase:
                    t = word[:i] + ch + word[i + 1:]
                    if ch != c and t in wordList:
                        res.append(t)
            return res

        wordList = set(wordList)
        q = [(beginWord, 1)]
        while q:
            word, dist = q.pop(0)
            wordList.discard(word)
            if word == endWord:
                return dist
            q.extend([(i, dist + 1) for i in get_next(word)])
        return 0
```