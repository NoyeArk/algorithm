# [LCR 111. 除法求值](https://leetcode.cn/problems/vlzXQL/description/)

> **日期**：2025-09-02
> **所用时间**：10min

## 1. DFS

本题是典型的**带权有向图的路径权值积查询**问题。题目给定若干形如 $A / B = k$ 的等式，要求对于若干查询 $X / Y$，返回其结果（若无法计算则返回 $-1$）。

### 1. 建图思路

- 每个变量看作图中的一个节点。
- 每个等式 $A / B = k$，在图中连两条有向边：
    - $A \to B$，权值为 $k$
    - $B \to A$，权值为 $1/k$
- 这样，任意两个变量之间的除法关系都可以通过图上的路径权值连乘得到。

### 2. 查询实现

- 对于每个查询 $X / Y$，在图中从 $X$ 出发，DFS/BFS 寻找 $Y$，路径上所有边的权值连乘即为结果。
- 若 $X$ 或 $Y$ 不在图中，或无法从 $X$ 到达 $Y$，返回 $-1$。

### 3. 代码实现要点

- 用 `defaultdict(list)` 存储邻接表，边权为浮点数。
- 用集合 `st` 记录所有出现过的变量，便于判断查询是否合法。
- DFS 时用 `vis` 集合避免重复访问节点，防止死循环。
- 递归终止条件：当前节点等于目标节点，返回 $1$（即 $X/X=1$）。
- 若找到一条路径，返回路径权值连乘；否则返回 $-1$。

### 4. 复杂度分析

- 时间复杂度：$O(m + qn)$，其中 $n$ 为节点数，$m$ 为边数，$q$ 为查询数。
- 空间复杂度：$O(n)$，递归栈和路径存储，以及集合 `st`。

**Python3**

```python
class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:
        st = set()
        g = defaultdict(list)
        for i, [c1, c2] in enumerate(equations):
            g[c1].append((c2, values[i]))
            g[c2].append((c1, 1.0 / values[i]))
            st.add(c1)
            st.add(c2)

        def dfs(i, target):
            if i == target:
                return 1
            for j, weight in g[i]:
                if j not in vis:
                    vis.add(j)
                    res = dfs(j, target)
                    if res != -1:
                        return weight * res
            return -1

        ans = []
        for c1, c2 in queries:
            if c1 not in st or c2 not in st:
                ans.append(-1.0)
            else:
                vis = {c1}
                ans.append(dfs(c1, c2))
        return ans
```