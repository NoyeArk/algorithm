# [LCR 107. 01 矩阵](https://leetcode.cn/problems/01-matrix/description/)

> **日期**：2025-07-26
> **所用时间**：23min

## 1. 从 1 向外 BFS

最直接的思路是对每个 1 位置，向四周做 BFS，直到遇到 0，记录步数。这样做时间复杂度较高，最坏情况下会超时。

**Python3**

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        n, m = len(mat), len(mat[0])
        ans = [[0] * m for _ in range(n)]
        
        def bfs(i, j):
            q = [(i, j, 0)]
            vis = {}
            while q:
                a, b, dist = q.pop(0)
                vis[(a, b)] = True
                for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                    x, y = a + dx, b + dy
                    if x < 0 or x >= n or y < 0 or y >= m or (x, y) in vis:
                        continue
                    if mat[x][y] == 0:
                        return dist + 1
                    q.append((x, y, dist + 1))
            return None

        for i in range(n):
            for j in range(m):
                if mat[i][j] == 0:
                    continue
                ans[i][j] = bfs(i, j)
        return ans
```

## 2. 从0向外BFS

本题的关键在于：**所有的 0 都是 BFS 的起点**，我们可以把所有 0 一起入队，然后从这些 0 向外一层层扩展，第一次被访问到的位置，其距离就是最短距离。

具体做法如下：

1. 初始化结果矩阵 ans，所有 0 位置为 0，其余为 -1（或无穷大）。
2. 将所有 0 的坐标加入队列 queue。
3. 从队列中取出一个点 (x, y)，遍历其上下左右四个方向的邻居 (nx, ny)：
   - 如果邻居未被访问过（即 ans[nx][ny] == 0），则 ans[nx][ny] = ans[x][y] + 1，并将 (nx, ny) 加入队列。
4. 队列为空时，所有点的最短距离都已计算完毕。

复杂度分析：

- 时间复杂度：$O(nm)$，每个点最多只会被访问一次。
- 空间复杂度：$O(nm)$，队列和结果矩阵需要额外空间。

**Python3**

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        n, m = len(mat), len(mat[0])
        ans = [[0] * m for _ in range(n)]

        q = []
        for i in range(n):
            for j in range(m):
                if mat[i][j] == 0:
                    q.append((i, j))
        
        while q:
            i, j = q.pop(0)
            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                x, y = i + dx, j + dy
                if x < 0 or x >= n or y < 0 or y >= m or mat[x][y] == 0 or ans[x][y]:
                    continue
                ans[x][y] = ans[i][j] + 1
                q.append((x, y))
        return ans
```