# [30. 串联所有单词的子串](https://leetcode.cn/problems/substring-with-concatenation-of-all-words/description/)

> **日期:** 2024-09-03、2025-12-28  
> **所用时间:** 30min  
> **知识点**: 哈希表、滑动窗口

## 1. 滑动窗口

本题给定一个字符串 s 和一个字符串数组 words，要求在 s 中找出所有子串，这些子串恰好可以由 words 中的每个单词串联而成（每个单词用一次，任意顺序），返回这些子串的起始下标。words 中所有单词长度相同。

**思路：滑动窗口+哈希表**

1. 计数：统计 words 中每个单词出现次数（Counter/哈希表）。
2. 枚举起点：由于单词长度为 n，对于每个 0,1,..., n-1 为起点分别滑动窗口遍历。
3. 滑动窗口：每次向右扩展一个单词长度，统计窗口内单词出现次数，
   - 和 words 的计数器比较，若窗口单词出现次数超出要求，则左指针右移，直到有效；
   - 若窗口内恰好包含 m 个单词且和 words 匹配，则收获一个答案。

复杂度分析：

- 时间复杂度: $O(nw)$，$n$ 为 $s$ 长度，$w$ 为 $words$ 中单词长度（每个窗口最坏遍历一次）
- 空间复杂度: $O(mw)$，$m$ 为 $words$ 数量

**Python3**
```python
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        m, n = len(words), len(words[0])

        ans = []
        for i in range(0, n):
            cnts = Counter(words)
            for j in range(i, len(s), n):
                word = s[j:j+n]
                if word in cnts:
                    cnts[word] -= 1
                if j - m * n >= i:  # 窗口左移，删除一个单词
                    sub_s = s[j-m*n:j-(m-1)*n]
                    if sub_s in cnts:
                        cnts[sub_s] += 1
                if all(cnt == 0 for cnt in cnts.values()):  # 窗口内恰好包含 m 个单词且和 words 匹配
                    ans.append(j-(m-1)*n)
        return ans
```

**C++**

```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> ans;
        int n = s.size(), m = words.size(), w = words[0].size();
        unordered_map<string, int> map;
        for (auto word : words) map[word] ++;

        for (int i = 0; i < w; i ++)
        {
            unordered_map<string, int> cur;
            for (int j = i; j + w <= n; j += w)
            {
                string sub = s.substr(j, w);
                if (j >= i + (m * w)) 
                {
                    string tmp = s.substr(j - m * w, w);
                    if (-- cur[tmp] == 0) cur.erase(tmp);
                }
                cur[sub] ++;
                if (map == cur) ans.push_back(j - (m - 1) * w);
            }
        }
        return ans;
    }
};
```

## 2. 自己做的垃圾版本...

```C++
class Solution {
public:
    void print_map(unordered_map<string, int> map)
    {
        printf("此时map中的元素为：\n");
        for (auto it : map) cout << it.first << " " << it.second << endl;
    }

    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> ans;
        // 初始化哈希表
        unordered_map<string, int> map, need;
        for (auto str : words) map[str] = 0, need[str] ++;
        // 窗口大小为n
        int m = words[0].size(), n = words.size();
        // 维护的窗口为[i, j]，cnt记录当前窗口中匹配words的字符串的个数
        int i = 0, j = 0, cnt = 0;
        while (i + n * m <= s.size())
        {
            cout << "j:" << j << endl;
            string tar = s.substr(j, m);
            printf("此时要匹配的字符串是%s\n", tar.c_str());
            if (map.find(tar) == map.end())
            {
                printf("%s不在words中,窗口设置为[%d, %d]\n", tar.c_str(), j + 1, j + 1);
                // tar不在words中
                cnt = 0;
                // 清空哈希表
                for (auto& it : map) it.second = 0;
                // 重新设置窗口位置
                i = j = i + 1;
            }
            else if (map[tar] < need[tar])
            {
                printf("%s在words中，加1之后的次数为%d，需要的次数为%d，窗口更新为[%d, %d]\n", tar.c_str(), map[tar] + 1, need[tar], i, j + m);
                // tar出现的次数小于需要的
                map[tar] ++;
                // 窗口扩大为[i, j + m]
                j += m;
                // 更新cnt
                if (++ cnt == n) 
                {
                    cout << "cnt:" << cnt << endl;
                    for (auto it : map) cout << it.first << " " << it.second << endl;
                    ans.push_back(i);
                    cnt = 0, i = j = i + 1;
                    for (auto& it : map) it.second = 0;
                }
            }
            else if (map[tar] == need[tar])
            {
                // tar出现的次数已经和需要的相等了，此时需要将i向前移动，直到tar出现次数小于need[tar]
                // while (map[tar] == need[tar])
                // {
                //     string subs = s.substr(i, m);
                //     map[subs] --, cnt --;
                //     i += m;
                //     printf("tar出现次数超过了need，进行删除，此时窗口更新为[%d, %d]\n", i, j);
                //     print_map(map);
                // }
                cnt = 0, i = j = i + 1;
                for (auto& it : map) it.second = 0;
                cout << "重置i和j：[" << i << ", " << j << "]" << endl;
            }
        }
        return ans;
    }
};
```