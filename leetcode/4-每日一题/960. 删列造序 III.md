# [960. 删列造序 III](https://leetcode.cn/problems/delete-columns-to-make-sorted-iii/description/)

> **日期**：2025-12-22
> **所用时间**：22min
> **知识点**：字符串、动态规划

## 题解详解：最长递增子序列(LIS)思想求删列最少数

本题是经典的“删列造序”问题的进阶，需要删去尽量少的列，使得删完后所有字符串数组在字典序上“非递减”。和原版相比，最大的不同在于不仅仅要求每一列递增，还要求删除“任意列”后字符串**整体按行非递减**。常规的贪心不再适用，我们需要用更全局的动态规划思想。

### 1. 问题建模

我们可以把每个字符串当做是一行，横向看所有字符串，第 $j$ 列 $(0 \leq j < n)$ 相当于都对齐在一起。每次可以自由选择一些列删除。

我们要在 $n$ 列中，保留若干列（不要求连续），保证删掉剩下的那些位置后，所有行“新拼出来的字符串”满足字典序非递减，要求删的列数**最少**。

本质上，这等价于：求所有可选列的集合 $S$，使得对于所有 $i$ 行，有 $\text{strs}[0][S] \leq \text{strs}[1][S] \leq \cdots \leq \text{strs}[m-1][S]$，且 $|S|$ 最大。

换句话说，**我们要求保留的列组成的“最长递增子序列”列集**。

### 2. 动态规划思路——LIS变形

在“行数为1”时，这就是真正的“LIS”（最长递增子序列）问题。

本题由于有多行，我们可以把“列”抽象为“状态”，求一组最多能选多少个列，它们**相对顺序被保留**的前提下，所有字符串拼出来依然是字典序正确的。

#### 状态定义

- 设 $dp[i]$ 表示以第 $i$ 列结尾，能满足条件的“最多可保留列数”。

#### 状态转移

- 初始：每一列都至少可以只保留自己，$dp[i]=1$。
- 枚举所有 $j<i$，如果对于所有行 $k$，有 $\text{strs}[k][j] \leq \text{strs}[k][i]$（即第$j$列的字符都 ≤ 第$i$列），那么我们可以把$i$加在以$j$结尾的列集后，即：$dp[i]=\max(dp[i], dp[j]+1)$。

#### 恰当性说明

- 这等价于：在本题多行情况下，LIS的“递增”要求是必须对于**所有字符串**都成立。
- 每一步，我们实际在做“在所有可扩展的前一列基础上接上当前列”，只要所有行都满足就行了。

#### 最终答案

- 所有 $dp[i]$ 中最大值记为 $maxlen$
- 答案即为 $n-maxlen$，因为总共有 $n$ 列，要保留最长合规子序列列数，剩下的都是待删的列。

### 3. 复杂度分析

- 外层 $i$ 列，内层 $j<i$ 枚举，$O(n^2)$
- 判断所有字符串 $O(m)$
- 总体复杂度 $O(n^2\cdot m)$，本题 $n,m\leq 100$，可接受

### 4. 例子分析

以样例数据：

```python
strs = ["ca","bb","ac"]
```

- 第一列（0）：["c","b","a"]  
- 第二列（1）：["a","b","c"]

流程：

- 以第0列结尾, 只能单独保留，dp[0]=1
- 以第1列结尾，看能否在前面加上0
    - 每行都满足 strs[*][0] <= strs[*][1] 吗？
        - strs[0]: c <= a (False)
        - 所以不能相连，只能单独作为一个新子序列，dp[1]=1

最后dp=[1,1]，maxlen=1，答案=2-1=1。  
和我们观察到的操作一致：删除第0列后["a","b","c"]，有序。

### 5. 代码讲解

对应上面解释，代码如下：

```python
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        n = len(strs[0])

        @cache
        def dfs(i):
            res = 1
            for j in range(i):
                # 判断所有字符串在第j列≤第i列
                if all(s[j] <= s[i] for s in strs):
                    res = max(res, dfs(j) + 1)
            return res
        
        # 最大可保留的列数
        return n - max(dfs(i) for i in range(n))
```

- 用递归+记忆化枚举每个$i$结尾的状态
- 对于每个$j<i$，只要所有行都能保证递增，就可以拼接起来
- 最终答案是总列数减去最大“合规序列”长度

### 6. 总结

本题本质是“列的最长递增子序列”多行条件下的动态规划。考察：
- 多行全局判断递增约束
- 状态设计与转移
- 动态规划理解的灵活应用

比单行LIS复杂，适合训练“多维LIS”的思维与基本功。

