# [712. 两个字符串的最小ASCII删除和](https://leetcode.cn/problems/minimum-ascii-delete-sum-for-two-strings/description/)

> **日期**：2026-01-10  
> **所用时间**：11min  
> **标签**：动态规划  

## 1. 题目描述

给定两个字符串 $s1$ 和 $s2$，删除 $s1$ 和 $s2$ 中的字符，使得 $s1$ 和 $s2$ 相等，并返回删除字符的ASCII值的最小和。

**示例 1：**

**输入：** s1 = "sea", s2 = "eat"

**输出：** 231

**解释：** 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。在 "eat" 中删除 "t" 并将 116 加入总和。结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。

**示例 2：**

**输入：** s1 = "delete", s2 = "leet"

**输出：** 403

**解释：** 在 "delete" 中删除 "dee" 字符串变成 "let"，将 100[d]+101[e]+101[e] 加入总和。在 "leet" 中删除 "e" 将 101[e] 加入总和。结束时，两个字符串都等于 "let"，结果即为 100+101+101+101 = 403 。如果改为将两个字符串转换为 "lee" 或 "eet"，我们会得到 433 或 417 的结果，比答案更大。


## 2. 动态规划

状态表示：$f[i][j]$ 表示使 $s1$ 的前 $i$ 个字符与 $s2$ 中的前 $j$ 个字符相等所需要删除字符的ASCII值的最小和

状态计算：

1. 如果 $s1[i] = s2[j]$，那么 $f[i][j]$ 等于使 $s1$ 中前 $i-1$ 个和 $s2$ 中前 $j-1$ 个字符匹配所需要删除字符的ASCII值的最小和，得状态转移方程如下：

$$
	f[i][j] = f[i - 1][j - 1]
$$

2. 如果 $s1[i] \neq s2[j]$，那么 $f[i][j]$ 等于删除 $s1$ 的第 $i$ 个、删除 $s2$ 中第 $j$ 个字符和同时删除 $s1$ 中的第 $i$ 个字符和 $s2[j]$ 这3种方案中的最小值，得状态转移方程如下：

$$
	f[i][j] = min(f[i - 1][j] + s1[i], f[i][j - 1] + s2[j]);
$$

$$
    f[i][j] = min(f[i][j], f[i - 1][j - 1] + s1[i] + s2[j]);
$$

初始化：

当 $i = 0$ 时，$f[0][j]$ 表示使 $s1$ 的前 $0$ 个字符与 $s2$ 中的前 $j$ 个字符相等所需要删除字符的ASCII值的最小和，得初始化方程如下：

$$
	f[0][j] = f[0][j - 1] + ord(s2[j])
$$

当 $j = 0$ 时，$f[i][0]$ 表示使 $s1$ 的前 $i$ 个字符与 $s2$ 中的前 $0$ 个字符相等所需要删除字符的ASCII值的最小和，得初始化方程如下：

$$
	f[i][0] = f[i - 1][0] + ord(s1[i])
$$

最终答案为 $f[n][m]$ ，即 $s1$ 的前 $n$ 个字符和 $s2$ 中的前 $m$ 个字符相等所需要删除字符的ASCII值的最小和

复杂度分析：

- 时间复杂度：$O(nm)$
- 空间复杂度：$O(nm)$

**Python3**

```python
class Solution:
    def minimumDeleteSum(self, s1: str, s2: str) -> int:
        n, m = len(s1), len(s2)

        f = [[0] * (m + 1) for _ in range(n + 1)]
        for i in range(n):
            f[i + 1][0] = f[i][0] + ord(s1[i])
        for j in range(m):
            f[0][j + 1] = f[0][j] + ord(s2[j])
        
        for i in range(n):
            for j in range(m):
                if s1[i] == s2[j]:
                    f[i + 1][j + 1] = f[i][j]
                else:
                    f[i + 1][j + 1] = min(f[i + 1][j] + ord(s2[j]), f[i][j + 1] + ord(s1[i]))
        return f[n][m]
```