# [2943. 最大化网格图中正方形空洞的面积](https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/description/)

> **日期**：2026-01-15  
> **所用时间**：11min  
> **知识点**: 贪心

## 1. 题目描述

给你一个网格图，由 n + 2 条 横线段 和 m + 2 条 竖线段 组成，一开始所有区域均为 1 x 1 的单元格。

所有线段的编号从 1 开始。

给你两个整数 n 和 m 。

同时给你两个整数数组 hBars 和 vBars 。

- hBars 包含区间 [2, n + 1] 内 互不相同 的横线段编号。
- vBars 包含 [2, m + 1] 内 互不相同的 竖线段编号。

如果满足以下条件之一，你可以 移除 两个数组中的部分线段：

- 如果移除的是横线段，它必须是 hBars 中的值。
- 如果移除的是竖线段，它必须是 vBars 中的值。

请你返回移除一些线段后（可能不移除任何线段），剩余网格图中 最大正方形 空洞的面积，正方形空洞的意思是正方形 内部 不含有任何线段。

![image.png](../images/2943.%20最大化网格图中正方形空洞的面积.png)

## 2. 贪心

本题目考察的是如何删除部分横、竖线段，使得网格上能够形成最大的“正方形空洞”。

### 思路 & 分析

1. **空洞的定义**  
   - 横线段每去掉一根，可以让一组 1x1 的网格合并成更高的格子；
   - 竖线段每去掉一根，可以让一组 1x1 的网格合并成更宽的格子。

2. **最大正方形空洞的本质**  
   最大的正方形空洞边长 = 可连续移除横线的最长连续段数 + 1 与可连续移除竖线的最长连续段数 + 1 中的较小值。

   - 例如，如果可以连续移除3根横线，则最多形成 4 单位高的空间，以此类推，竖线也同理。
   - 横线和竖线分别看做一维坐标，统计 hBars 和 vBars 中最长的连续段。

3. **贪心策略实现**  
   - 对 hBars、vBars 排序，找出其中最长的连续数字段的长度（如有 [3,4,5,8,9] 最长连续段长度为 3）。
   - 答案就是 min(横向最长连续长度, 纵向最长连续长度)+1 的平方。

### 复杂度分析

- 时间复杂度: $O(h \log h + v \log v)$
- 空间复杂度: $O(1)$

**Python3**

```python
class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        def get_f(nums):
            nums.sort()
            mx = cnt = 0
            for i, x in enumerate(nums):
                if i > 0 and x == nums[i - 1] + 1:
                    cnt += 1
                else:
                    cnt = 1
                mx = max(mx, cnt)
            return mx

        h_max, v_max = get_f(hBars), get_f(vBars)
        return (min(h_max, v_max) + 1)**2
```

## 3. 不排序，空间换时间

与前面的排序写法不同，这里用 **哈希集合（set）** 来加速查找连续段：
- 对于每根（横、竖）线，我们都放进集合里。
- 然后依次遍历集合，对于每一个 "起点" $x$（即 $x-1$ 不在集合中），向后查找连续的 $x+1, x+2, \ldots$，直到断裂，记录长度。
- 这样每个连续段只会被枚举一次。

### 复杂度分析

- 时间复杂度: $O(h + v)$
- 空间复杂度: $O(h + v)$

**Python3**

```python
class Solution:
    def maximizeSquareHoleArea(self, n: int, m: int, hBars: List[int], vBars: List[int]) -> int:
        def get_f(nums):
            st = set(nums)
            mx = 0
            for x in st:
                if x - 1 in st:
                    continue  # 不是连续段开头
                y = x + 1
                while y in st:
                    y += 1
                mx = max(mx, y - x)
            return mx

        h_max, v_max = get_f(hBars), get_f(vBars)
        return (min(h_max, v_max) + 1)**2
```