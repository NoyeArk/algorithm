# [1382. 将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/description/)

> **日期**：2025-02-09  
> **所用时间**：8min  
> **知识点**：二叉搜索树，平衡树，递归，中序遍历

## 1. 题目描述

给你一棵二叉搜索树（BST），请你返回一棵**平衡后**的二叉搜索树。新树应该与原来的树有着相同的节点值。如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是**平衡的**。

如果有多种构造方法，请你返回任意一种。

**示例 1：**

```
输入：root = [1,null,2,null,3,null,4,null,null]
输出：[2,1,3,null,null,null,4]
解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。
```

**示例 2：**

```
输入：root = [2,1,3]
输出：[2,1,3]
```

**提示：**

- 树节点的数目在 `[1, 10^4]` 范围内
- 每个节点的值都是唯一的
- 树节点的值在 `[1, 10^5]` 范围内

## 2. 中序遍历 + 分治法

由于二叉搜索树的中序遍历结果是有序数组，可以分两步完成：

1. **中序遍历**：对原 BST 进行中序遍历，得到有序数组 `nums`
2. **分治建树**：每次取数组中间元素作为根节点，递归构建左右子树，保证左右子树节点数量接近，从而得到平衡树

复杂度分析：
- 时间复杂度：$O(n)$，其中 $n$ 为树中节点个数。中序遍历 $O(n)$，分治建树 $O(n)$
- 空间复杂度：$O(n)$，存储有序数组及递归栈

**Python3**

```python
class Solution:
    def balanceBST(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        def get_nums(root):
            if not root:
                return []
            return get_nums(root.left) + [root.val] + get_nums(root.right)
        nums = get_nums(root)

        def dfs(l, r):
            if l > r:
                return None
            if l == r:
                return TreeNode(nums[l])
            mid = l + r >> 1
            return TreeNode(nums[mid], dfs(l, mid - 1), dfs(mid + 1, r))
        return dfs(0, len(nums) - 1)
```
