# [3719. 最长平衡子数组 I](https://leetcode.cn/problems/longest-balanced-subarray-i/description/)

> **日期**：2026-02-10  
> **所用时间**：5min  
> **知识点**：数组、枚举

## 1. 题目描述

给你一个整数数组 `nums`。如果一个子数组中不同奇数的个数等于不同偶数的个数，那么我们称这个子数组是**平衡的**。

请你返回 `nums` 中**最长平衡子数组**的长度。

**示例 1：**

```
输入：nums = [1,2,3,4,5]
输出：5
解释：子数组 [1,2,3,4,5] 是平衡的，因为：
- 不同奇数：{1,3,5}，共 3 个
- 不同偶数：{2,4}，共 2 个
注意：实际上子数组 [1,2,3,4] 也是平衡的（奇数 {1,3}，偶数 {2,4}，各 2 个），但最长的是整个数组。
```

**示例 2：**

```
输入：nums = [2,2,2,2]
输出：4
解释：子数组 [2,2,2,2] 是平衡的，因为：
- 不同奇数：{}，共 0 个
- 不同偶数：{2}，共 1 个
实际上，如果子数组中只有偶数，那么不同奇数的个数为 0，不同偶数的个数也为 0（如果所有偶数都相同）或 1（如果只有一个不同的偶数）。
```

**提示：**

- $1 \leq nums.length \leq 100$
- $1 \leq nums[i] \leq 100$

## 2. 暴力枚举

对于每个位置 $i$，从 $i$ 往前枚举所有可能的左端点 $j$，统计子数组 $[j, i]$ 中不同奇数的个数和不同偶数的个数。当两者相等时，更新答案。

具体实现：
- 使用两个集合 `odd` 和 `even` 分别记录当前子数组中不同的奇数和偶数
- 对于每个右端点 $i$，从 $i$ 往前遍历左端点 $j$
- 根据 `nums[j]` 的奇偶性，将其加入对应的集合
- 当 `len(odd) == len(even)` 时，更新最长长度

复杂度分析：
- 时间复杂度：$O(n^2)$，其中 $n$ 为数组长度。外层循环 $O(n)$，内层循环最多 $O(n)$
- 空间复杂度：$O(n)$，用于存储不同奇数和偶数的集合

**Python3**

```python
class Solution:
    def longestBalanced(self, nums: List[int]) -> int:
        ans = 0
        for i, x in enumerate(nums):
            odd = {x} if x % 2 == 1 else set()
            even = {x} if x % 2 == 0 else set()
            for j in range(i - 1, -1, -1):
                if nums[j] % 2 == 1:
                    odd.add(nums[j])
                else:
                    even.add(nums[j])
                if len(odd) == len(even):
                    ans = max(ans, i - j + 1)
        return ans
```