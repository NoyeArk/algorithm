# [1404. 将二进制表示减到 1 的步骤数](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/)

> **日期**：2026-02-26  
> **所用时间**：10min  
> **知识点**：模拟、位运算

## 1. 题目描述

给你一个以二进制形式表示的数字 `s`。请你返回将它变成 **1** 所需要的步数。

规则如下：

- 如果当前数字是**偶数**，则将其除以 2。
- 如果当前数字是**奇数**，则将其加 1。

题目保证 `s` 对应的十进制数一定可以经过若干步变成 1。

**示例 1：**

- **输入**：s = "1101"
- **输出**：6
- **解释**：二进制 "1101" 对应十进制 13。13 是奇数，加 1 得 14；14 是偶数，除以 2 得 7；7 是奇数，加 1 得 8；8 是偶数，除以 2 得 4；4 除以 2 得 2；2 除以 2 得 1。共 6 步。

**示例 2：**

- **输入**：s = "10"
- **输出**：1
- **解释**：二进制 "10" 对应 2，2 除以 2 得 1，共 1 步。

**示例 3：**

- **输入**：s = "1"
- **输出**：0
- **解释**：已经是 1，不需要操作。

**提示：**

- `1 <= s.length <= 500`
- `s` 由字符 `'0'` 和 `'1'` 组成
- `s[0] == '1'`（即二进制表示至少有一位且最高位为 1）

## 2. 模拟

直接模拟：先将二进制字符串转为整数，然后反复执行「若为偶数则除以 2，否则加 1」，并统计步数直到变为 1。偶数等价于最低位为 0，奇数等价于最低位为 1，因此用位运算实现除以 2（右移）和加 1 即可。

复杂度分析：

- 时间复杂度：$O(n + \log v)$，其中 $n$ 为字符串长度，$v$ 为数值；转整数 $O(n)$，模拟步数最多 $O(\log v)$（每次至少减半或加一后变偶数再减半）。
- 空间复杂度：$O(1)$（若不计转整数后的大整数存储）。

**Python3**

```python
class Solution:
    def numSteps(self, s: str) -> int:
        ans = 0
        s = int(s, 2)

        while s > 1:
            if s % 2 == 0:
                s >>= 1
            else:
                s += 1
            ans += 1
        return ans
```