# [761. 特殊的二进制字符串](https://leetcode.cn/problems/special-binary-string/description/)

> **日期**：2026-02-20  
> **所用时间**：5min  
> **知识点**：递归、分治

## 1. 题目描述

**特殊的二进制序列**满足以下两个性质：

- 序列中 `0` 的个数与 `1` 的个数相等；
- 序列的**每一个前缀**里，`1` 的个数都**大于等于** `0` 的个数。

你可以进行任意次操作：每次选择字符串中两个**连续且非空**的「特殊子串」，交换它们的位置。请返回经过任意次操作后，能得到的**字典序最大**的字符串。

**示例 1：**

```
输入：s = "11011000"
输出："11100100"
解释：例如将子串 "10"（下标 1 起）与 "1100"（下标 3 起）交换，得到 "11100100" 等，其中字典序最大的即为答案。
```

**提示：**

- `1 <= s.length <= 50`
- `s` 仅由 `'0'` 和 `'1'` 组成
- `s` 是特殊的二进制序列

## 2. 递归分解 + 按字典序排序后拼接

将 `s` 拆成若干**最小特殊子串**：用差分（遇 `1` 加一、遇 `0` 减一）扫描，当差分再次为 0 时截出一段，形如 `1 + 中间 + 0`，中间部分递归处理得到字典序最大。把所有这样的子串按**字典序从大到小**排序后拼接，即为当前层的最优结果。

复杂度分析：

- **时间复杂度**：$O(n^2)$（递归层数 × 每层排序）。
- **空间复杂度**：$O(n)$（递归栈及临时字符串）。

**Python3**

```python
class Solution:
    def makeLargestSpecial(self, s: str) -> str:
        if len(s) <= 2:
            return s
        
        sub_s = []
        diff = 0
        st = 0
        for i, c in enumerate(s):
            if c == '1':
                diff += 1
            else:
                diff -= 1
                if diff == 0:
                    sub_s.append('1' + self.makeLargestSpecial(s[st + 1: i]) + '0')
                    st = i + 1
        
        sub_s.sort(reverse=True)
        return ''.join(sub_s)
```