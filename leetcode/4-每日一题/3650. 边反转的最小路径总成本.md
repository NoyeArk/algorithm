# [3650. 边反转的最小路径总成本](https://leetcode.cn/problems/minimum-cost-to-reverse-edges-on-a-graph/description/)

> **日期**：2026-01-27
> **所用时间**：27min
> **知识点**：最短路、最小生成树

## 1. 堆优化迪杰斯特拉

本题是 LeetCode 第3650题《边反转的最小路径总成本》，考察带权图和最短路算法。

### 题意简述

给定一个 $n$ 个点的有向带权图，每条边 $(a, b, w)$ 可以使用原方向 $(a \to b, \text{花费}~w)$，或者**反转方向** $(b \to a, \text{花费}~2w)$。从 $0$ 号点出发，问到 $n-1$ 号点的最小总花费是多少。

### 思路分析

- 由于每条边可以选择“正向走”或“逆向反转”，可以建一个**双向图**（正向边权$w$，反向边权$2w$）。
- 建图后，在$n$个点上跑最短路即可。
- 因为 $w \geq 1$，且反向权值 $2w > w$，不存在负权。最短路采用 Dijkstra 堆优化。

### 步骤

1. 建邻接表，对于每条 $(a, b, w)$，添加 $(a, b, w)$ 和 $(b, a, 2w)$。
2. Dijkstra 求 $0 \to n-1$ 的最小花费。

#### 复杂度

- 时间复杂度：$O(m\log n)$，$m$为边数，$n$为点数。
- 空间复杂度：$O(m+n)$。

### 核心技巧

- 用邻接表建双向边，并让正反向花费不同，实现“可以选择反转”。
- 最短路可视作经典 Dijkstra，只需按权值不同建图。

**Python3**

```python
class Solution:
    def minCost(self, n: int, edges: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for a, b, w in edges:
            g[a].append((b, w))
            g[b].append((a, w * 2))
        
        dis = [inf] * n
        dis[0] = 0
        h = [(0, 0)]

        while h:
            t, a = heappop(h)
            if t > dis[a]:
                continue
            if a == n - 1:
                return t
            for b, w in g[a]:
                if dis[b] > t + w:
                    dis[b] = t + w
                    heappush(h, (dis[b], b))
        return -1
```