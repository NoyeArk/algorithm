# [2147. 分隔长廊的方案数](https://leetcode.cn/problems/number-of-ways-to-divide-a-long-corridor/description/)

> **日期**：2025-12-14
> **所用时间**：25min
> **知识点**：数学、字符串

## 1. 记忆化搜索

这道题要求将长廊分隔成若干段，每一段恰好有2个座位（'S'），问有多少种分隔方法。我们使用记忆化搜索（递归+缓存）来做。

**思路：**

1. 从左到右枚举每个字符，统计座位'S'的数量，每次正好统计到2个'S'时才可以分隔。
2. 对于每一次分割，我们递归计算剩余部分能分割的方案数，累加起来就是总方案数。

**复杂度分析：**
- 时间复杂度：$O(n^2)$。最坏每个字符都尝试分割，嵌套一次for循环。
- 空间复杂度：$O(n)$。递归栈和缓存空间。

由于题目所给 $n$ 的范围为 $1 \leq n \leq 10^5$，所以时间复杂度 $O(n^2)$ 会超时。

**Python3**

```python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        n = len(corridor)

        @cache
        def dfs(i):
            # dfs(i) 表示区间 [i, n-1] 有多少个方案
            if i == n:
                return 1

            cnt = res = 0
            for j in range(i, n):
                if corridor[j] == 'S':
                    cnt += 1
                if cnt == 2:
                    res += dfs(j + 1)
                elif cnt > 2:
                    break
            return res % int(1e9 + 7)

        return dfs(0)
```

## 2. 贪心

题目可以转化为：每两个连续的'S'组成一个区间，两个区间之间的'P'决定了可以分割的位置数，如果有k个P，就有k+1个位置可以分割（每个P之前、之后，以及两端），不同区间之间的分割方案相互独立，使用乘法原理。

**变量说明：**
- `ans`：最终答案，初始化为1（乘法原理的初始值）
- `cur_s_cnt`：当前区间内已统计的座位'S'数量
- `cur_p_cnt`：当前两个座位区间之间植物'P'的数量

**算法流程：**

1. **遍历每个字符**：
   - **遇到'S'时**：
     - 如果 `cur_s_cnt == 2`，说明当前区间已经完整（包含2个座位），此时需要：
       - 计算分割方案数：两个座位区间之间有 `cur_p_cnt` 个植物，可以在每个植物之前或之后分割，共有 `cur_p_cnt + 1` 种分割方式
       - 使用乘法原理累乘：`ans = ans * (cur_p_cnt + 1)`
       - 重置计数器，开始统计下一个区间
     - 将当前S计数加1
   
   - **遇到'P'时**：
     - 只有当 `cur_s_cnt == 2` 时（即当前区间已经完整），才统计P的数量
     - 因为只有两个完整区间之间的P才影响分割方案数

2. **最终检查**：
   - 如果 `cur_s_cnt == 2`，说明最后一对座位也完整，返回答案
   - 否则说明座位数不是偶数或最后一对不完整，返回0

**关键理解：**
- 每两个连续的'S'组成一个区间
- 两个区间之间的'P'决定了可以分割的位置数
- 如果有k个P，就有k+1个位置可以分割（每个P之前、之后，以及两端）
- 不同区间之间的分割方案相互独立，使用乘法原理

**示例分析：**

以 `corridor = "SSPPSPS"` 为例：

```
S S P P S P S
│ │     │   │
1 2     3   4
```

- 位置1-2：第一个区间（S S）
- 位置2-3之间：有2个P（P P），可以分割的位置有3个（P之前、两个P之间、P之后）
- 位置3-4：第二个区间（S S）
- 最终答案：3种分割方案

**复杂度分析：**
- 时间复杂度：$O(n)$，只需遍历一次字符串
- 空间复杂度：$O(1)$，只使用了常数额外空间

**Python3**

```python
class Solution:
    def numberOfWays(self, corridor: str) -> int:
        ans = 1
        cur_s_cnt = cur_p_cnt = 0

        for c in corridor:
            if c == 'S':
                if cur_s_cnt == 2:
                    ans = (ans * (cur_p_cnt + 1)) % int(1e9 + 7)
                    cur_s_cnt = cur_p_cnt = 0
                cur_s_cnt += 1
            else:
                if cur_s_cnt == 2:
                    cur_p_cnt += 1

        return ans if cur_s_cnt == 2 else 0
```