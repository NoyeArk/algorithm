# [1351. 统计有序矩阵中的负数](https://leetcode.cn/problems/count-negative-numbers-in-a-sorted-matrix/description/)

> **日期**：2025-12-28  
> **所用时间**：1min  
> **知识点**: 模拟、数学

## 1. 模拟

最直接的做法是遍历每一个元素，判断是否为负数并计数。这种做法时间复杂度为 $O(mn)$（$m,n$ 分别为行和列），对于题目中的数据规模是可接受的。

复杂度分析：

- 时间复杂度：暴力 $O(mn)$
- 空间复杂度：$O(1)$，仅需常数额外空间

**Python3**

```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        return sum(int(x < 0) for row in grid for x in row)
```

#### 2. 双指针（推荐解法）

利用矩阵的排序特性，可以用**双指针**优化。方法如下：

- 指针 $i$ 从上往下遍历行，指针 $j$ 从右往左遍历列，初始时 $i=0, j=n-1$。
- 如果当前位置 $grid[i][j]<0$，说明该列$j$下$i$及其下方的行在该列都为负数（因为同列向下更小），此时这些负数总共有 $m-i$ 个。计入答案后，左移一列（$j-=1$）。
- 如果当前位置 $grid[i][j]\geq0$，说明当前列的下方可能有负数，因此向下进入下一行（$i+=1$）。
- 重复上面过程，直到 $i$ 超过最后一行或 $j$ 小于0。

复杂度分析：

- 时间复杂度：$O(m+n)$
- 空间复杂度：$O(1)$，仅需常数额外空间

本题关键在于利用行和列的有序性，提高效率。推荐使用双指针法，可以将复杂度从 $O(mn)$ 降到 $O(m+n)$。

**Python3**

```python
class Solution:
    def countNegatives(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])

        ans = 0
        i, j = 0, n - 1
        while i < m and j >= 0:
            if grid[i][j] < 0:
                ans += m - i
                j -= 1
            else:
                i += 1
        return ans
```