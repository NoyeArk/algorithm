# [865. 具有所有最深节点的最小子树](https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes/description/)

> **日期**：2026-01-09  
> **所用时间**：39min  
> **知识点**: 树、深度优先搜索、广度优先搜索  
> **总结**: 一开始没理解好题意，导致浪费了很多时间

## 1. 题目描述

示例 1：

        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

黄色表示 2 节点，蓝色为 7 节点和 4 节点。

输入：root = [3,5,1,6,2,0,8,null,null,7,4]  
输出：[2,7,4]  
解释：  
我们返回值为 2 的节点，在图中用黄色标记。  
在该节点的子树中，包含所有最深的节点。  
注意，节点 5，3，和 2 包含全部最深的节点，但是节点 2 的子树最小，所以我们返回它。

示例 2：

输入：root = [1]  
输出：[1]  
解释： 根节点是树中最深的节点。

示例 3：

输入：root = [0,1,3,null,2]  
输出：[2]  
解释： 树中最深的节点为 2，有效子树为节点 2、1 和 0 的子树，但节点 2 的子树最小。

## 2. 深度优先搜索

题目要求找到一个最小的子树，使得该子树包含了所有最深节点。这个问题可以转化为如何同时找到所有最深节点的最近公共祖先（LCA）。

**思路解析：**

1. **深度优先搜索**  
   对于每个节点，递归处理其左右子树，分别返回左右子树中最深节点的深度以及包含这些最深节点的最近公共祖先。
   
2. **递归返回内容**  
   设计递归函数返回一个二元组：(当前子树最深的深度, 该深度下最小包含所有最深节点的子树根节点)。
   
3. **合并结果**  
   - 如果左、右子树返回的最大深度相同，则当前节点即为左右最深节点的最近公共祖先；
   - 否则，较深一侧的祖先上移。

4. **递归出口**  
   递归到空节点时，深度为当前的深度减一，祖先为None。

**图示分析：**

以示例1为例：

        3
       / \
      5   1
     / \ / \
    6  2 0  8
      / \
     7   4

- 7、4 是最深节点，深度都是4。
- 包含这两个节点的最小子树是2，所以返回2。

**代码实现思路**：

- 用后序递归。
- 每次递归返回最深深度和当前节点。
- 两边深度最大且相等时，祖先就是当前节点。

**为什么能这样做？**

本质上，这是“树的直径”在根上的题变形，只是这里要找的是所有最深节点的LCA。

**复杂度分析：**

- 时间复杂度：每个节点遍历一次，$O(n)$。
- 空间复杂度：递归栈最坏$O(n)$。

**Python3**

```python
class Solution:
    def subtreeWithAllDeepest(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        ans = None
        max_level = 0

        def dfs(root, depth):
            if not root:d
                return depth - 1
            
            nonlocal ans, max_level
            max_level = max(max_level, depth)

            left_max_level = dfs(root.left, depth + 1)
            right_max_level = dfs(root.right, depth + 1)
            if max_level == left_max_level == right_max_level:
                ans = root
            return max(left_max_level, right_max_level)

        dfs(root, 1)
        return ans
```