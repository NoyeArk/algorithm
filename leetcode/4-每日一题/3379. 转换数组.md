# [3379. 转换数组](https://leetcode.cn/problems/convert-array/description/)

> **日期**：2026-02-05  
> **所用时间**：3min  
> **知识点**：数组、模拟

## 1. 题目描述

给定一个**循环**整数数组 `nums`，创建一个结果数组，其中对于每个索引 `i`：
- 如果 `nums[i] > 0`：向右移动 `nums[i]` 步，将 `result[i]` 设置为该位置的值
- 如果 `nums[i] < 0`：向左移动 `|nums[i]|` 步，将 `result[i]` 设置为该位置的值
- 如果 `nums[i] == 0`：将 `result[i]` 设置为 0

数组是循环的，即索引会环绕。

**示例 1：**
```
输入：nums = [3,-2,1,1]
输出：[1,1,1,3]
解释：
- i=0: nums[0]=3，向右移动3步到位置(0+3)%4=3，result[0]=nums[3]=1
- i=1: nums[1]=-2，向左移动2步到位置(1-2+4)%4=3，result[1]=nums[3]=1
- i=2: nums[2]=1，向右移动1步到位置(2+1)%4=3，result[2]=nums[3]=1
- i=3: nums[3]=1，向右移动1步到位置(3+1)%4=0，result[3]=nums[0]=3
```

**示例 2：**
```
输入：nums = [-1,4,-1]
输出：[-1,-1,4]
解释：
- i=0: nums[0]=-1，向左移动1步到位置(0-1+3)%3=2，result[0]=nums[2]=-1
- i=1: nums[1]=4，向右移动4步到位置(1+4)%3=2，result[1]=nums[2]=-1
- i=2: nums[2]=-1，向左移动1步到位置(2-1+3)%3=1，result[2]=nums[1]=4
```

## 2. 解题算法

### 2.1 算法思路

这是一个简单的模拟题，核心是处理循环数组的索引计算：

1. **对于每个位置 `i`**：
   - 计算目标位置：`(i + nums[i]) % n`
   - 使用模运算处理循环数组的环绕

2. **处理负数的情况**：
   - 当 `nums[i] < 0` 时，向左移动相当于 `i + nums[i]`
   - 由于 `nums[i]` 是负数，`i + nums[i]` 可能是负数
   - 需要先加上 `n` 再取模，确保结果为正：`(i + nums[i] + n) % n`

3. **简化处理**：
   实际上，`(i + nums[i]) % n` 在 Python 中已经能正确处理负数，因为在 Python 中，负数取模会返回负数，而列表索引会自动处理负数索引为倒数第几个元素。

### 2.2 算法步骤

```
1. 初始化结果数组
2. 对于每个索引 i：
   a. 计算目标位置：target = (i + nums[i]) % len(nums)
   b. 如果 nums[i] == 0，result[i] = 0
   c. 否则，result[i] = nums[target]
3. 返回结果数组
```

### 2.3 复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 是数组长度。需要遍历数组一次。
- **空间复杂度**：$O(n)$，需要存储结果数组。

### 2.4 代码实现

**Python3**

```python
class Solution:
    def constructTransformedArray(self, nums: List[int]) -> List[int]:
        return [nums[(i + x) % len(nums)] for i, x in enumerate(nums)]
```