# [3634. 使数组平衡的最少移除数目](https://leetcode.cn/problems/minimum-number-of-removals-to-make-array-balanced/description/)

> **日期**：2026-02-06  
> **所用时间**：8min  
> **知识点**：排序、滑动窗口

## 1. 题目描述

给定一个整数数组 `nums` 和整数 `k`。若数组的**最大值**不超过**最小值**的 `k` 倍，则称该数组是**平衡**的。

求最少需要移除多少个元素，才能使剩余数组平衡。

**说明**：单个元素的数组视为平衡。

**示例 1：**
```
输入：nums = [2,1,5], k = 2
输出：1
解释：移除 5 后，剩余 [1,2]，max=2 ≤ min×k=1×2=2，平衡。
```

**示例 2：**
```
输入：nums = [1,6,2,9], k = 3
输出：2
解释：移除 1 和 9 后，剩余 [2,6]，max=6 ≤ min×k=2×3=6，平衡。
```

**示例 3：**
```
输入：nums = [4,6], k = 2
输出：0
解释：已平衡，max=6 ≤ min×k=4×2=8。
```

## 2. 解题算法

### 2.1 算法思路

等价于求**最长的平衡子数组**，答案即为 `n - 最长平衡子数组长度`。

平衡条件：`max ≤ min × k`。

1. **排序**：升序排序后，任意子数组的 min 为左端、max 为右端。
2. **双指针/滑动窗口**：枚举右端点 `r`，维护左端点 `l`，使得 `nums[l] × k ≥ nums[r]`，则 `[l, r]` 为平衡子数组。
3. **最大化窗口**：对每个 `r` 找到满足条件的最左 `l`，用 `r - l + 1` 更新最长平衡子数组长度。
4. **答案**：`len(nums) - 最长平衡子数组长度`。

### 2.2 算法步骤

```
1. 将 nums 升序排序
2. 初始化 l = 0, ans = 0
3. 枚举右端点 r：
   a. 若 nums[l] × k < nums[r]，则 l 右移直到 nums[l] × k ≥ nums[r]
   b. 用 r - l + 1 更新 ans
4. 返回 len(nums) - ans
```

### 2.3 复杂度分析

- **时间复杂度**：$O(n \log n)$，排序占主导，双指针为 $O(n)$。
- **空间复杂度**：$O(\log n)$，排序递归栈；若使用原地排序则为 $O(1)$。

### 2.4 代码实现

**Python3**

```python
class Solution:
    def minRemoval(self, nums: List[int], k: int) -> int:
        nums.sort()
        l = ans = 0
        for r, x in enumerate(nums):
            while nums[l] * k < x:
                l += 1
            ans = max(ans, r - l + 1)
        return len(nums) - ans
```