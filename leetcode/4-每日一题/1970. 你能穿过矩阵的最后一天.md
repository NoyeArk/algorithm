# [1970. 你能穿过矩阵的最后一天](https://leetcode.cn/problems/last-day-where-you-can-still-cross/description/)

> **日期**：2025-12-31  
> **所用时间**：20min  
> **知识点**: 二分、BFS

## 1. 二分 + BFS

每天能否穿过整个网格，可以等价为“第一行与最后一行是否连通”。由于每天有且只有一个格子被淹没，每一天的网格状态是单调递减的：天数越大，越难穿过。所以我们可以**二分答案**：找到最大的一天 `k`，在第 `k` 天还能穿过。

检查在第 `mid` 天对应格子状态下（前 `mid+1` 个格子都被淹没），能不能从第一行穿到最后一行。能跨过就继续二分右区间，否则左区间。

从第一行所有可用格子作为起点，BFS（宽度优先搜索），只在陆地格子中移动。只要 BFS 能访问到最后一行任意格子，即可判定“可以穿过”。

二分出来的下标 `r` 是最大的可行下标，但对应的天数实际是 `r + 1`，所以最后返回 `r + 1`。

复杂度分析：

- 时间复杂度：$O(row \times col \cdot \log(row \times col))$
- 空间复杂度：$O(row \times col)$

**Python3**

```python
class Solution:
    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:
        def check(mid):
            grids = [[0] * col for _ in range(row)]
            for r, c in cells[:mid+1]:
                grids[r - 1][c - 1] = 1
    
            q = [(0, c) for c in range(col) if grids[0][c] == 0]
            while q:
                x, y = q.pop(0)
                
                for dx, dy in [(-1, 0), (0, -1), (0, 1), (1, 0)]:
                    a, b = x + dx, y + dy
                    if a < 0 or a >= row or b < 0 or b >= col or grids[a][b] == 1:
                        continue
                    if a == row - 1:
                        return True
                    q.append((a, b))
                    grids[a][b] = 1
            return False

        l, r = 0, row*col - 1
        while l < r:
            mid = l + r + 1 >> 1
            if check(mid):
                l = mid
            else:
                r = mid - 1
        return r + 1
```