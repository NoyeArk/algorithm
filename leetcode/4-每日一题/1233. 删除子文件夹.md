# [1233. 删除子文件夹](https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem/description/)

> **日期**：2025-07-19
> **所用时间**：10min

## 1. 排序 + 字典树

### 题目分析

本题要求从一组文件夹路径中删除所有子文件夹，只保留每个文件夹的最顶层父文件夹。例如，`/a` 和 `/a/b`，只保留 `/a`，因为 `/a/b` 是 `/a` 的子文件夹。

### 解题思路

1. **排序**  
   首先将所有文件夹路径按字典序排序。这样父文件夹总是在子文件夹前面。

2. **字典树（Trie）建模**  
   用字典树存储每个文件夹路径。每插入一个路径时，如果在插入过程中遇到某个节点已经是终止节点（即之前插入过的父文件夹），说明当前路径是某个父文件夹的子文件夹，直接跳过即可。

3. **去重与收集答案**  
   只有在插入过程中没有遇到父文件夹终止节点的路径，才加入答案。

### 关键点

- 路径分割时要去掉第一个空字符串（因为 `/a/b` 用 `split('/')` 得到 `['', 'a', 'b']`）。
- 字典树节点用 `[is_end, children]` 结构，`is_end` 表示该节点是否为某个文件夹的结尾。
- 由于排序，父文件夹总是先于子文件夹插入，保证了判断的正确性。

### 复杂度分析

- 时间复杂度: $O(n \log n)$
- 空间复杂度: $O(n)$

**Python3**

```python
class Trie:
    def __init__(self):
        self.son = [False, {}]
    
    def insert(self, word):
        is_match = False
        cur = self.son
        for c in word:
            if cur[0]:
                is_match = True
            if c not in cur[1]:
                cur[1][c] = [False, {}]
            cur = cur[1][c]
        cur[0] = True
        return is_match

class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        tree = Trie()
        folder.sort()
        ans = []
        for s in folder:
            if not tree.insert(s.split('/')[1:]):
                ans.append(s)
        return ans
```

## 2. 排序 + 前缀判断

1. **排序**  
   先对所有文件夹路径排序，父文件夹一定在子文件夹前面。

2. **遍历判断**  
   用一个结果数组 `ans`，每次判断当前路径 `s` 是否是上一个加入结果的路径 `last` 的子文件夹。判断条件是：`s` 以 `last` 开头，且 `s[len(last)] == '/'`，否则就不是子文件夹，可以加入结果。

### 复杂度分析

- 时间复杂度: $O(n \log n)$
- 空间复杂度: $O(n)$

**Python3**

```python
class Solution:
    def removeSubfolders(self, folder: List[str]) -> List[str]:
        folder.sort()
        ans = [folder[0]]
        for s in folder[1:]:
            last = ans[-1]
            if not s.startswith(last) or s[len(last)] != '/':
                ans.append(s)
        return ans
```