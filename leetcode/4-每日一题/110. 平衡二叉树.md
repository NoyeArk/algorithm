# [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)

> **日期**：2026-02-08  
> **所用时间**：10min  
> **知识点**：二叉树、递归、DFS

## 1. 题目描述

给定一个二叉树，判断它是否是**高度平衡**的。

高度平衡二叉树的定义为：一个二叉树，其中**每个节点的左右子树的高度差不超过 1**。

**示例 1：**
```
输入：root = [3,9,20,null,null,15,7]
输出：true
解释：
    3
   / \
  9  20
    /  \
   15   7
左右子树高度差不超过 1，是平衡二叉树。
```

**示例 2：**
```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
解释：
    1
   / \
  2   2
 / \
3   3
   / \
  4   4
节点 1 的左右子树高度差为 2，不是平衡二叉树。
```

**示例 3：**
```
输入：root = []
输出：true
解释：空树视为平衡二叉树。
```

## 2. 解题算法

### 2.1 算法思路

采用 DFS 自底向上递归：

1. **dfs(root)** 返回以 root 为根的子树高度。
2. **平衡条件**：对每个节点，`|左子树高度 - 右子树高度| ≤ 1`。
3. **递归过程**：
   - 空节点返回高度 0。
   - 递归求左右子树高度。
   - 若 `|left - right| > 1`，标记为不平衡。
   - 返回当前子树高度：`max(left, right) + 1`。

### 2.2 复杂度分析

- **时间复杂度**：$O(n)$，其中 $n$ 为节点数，每个节点访问一次。
- **空间复杂度**：$O(h)$，递归栈深度为树高 $h$，最坏 $O(n)$。

### 2.3 代码实现

**Python3**

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        ans = True
    
        def dfs(root):
            if not root:
                return 0
            nonlocal ans
            left = dfs(root.left)
            right = dfs(root.right)
            ans &= abs(left - right) <= 1
            return max(left, right) + 1
        dfs(root)
        return ans
```