# [1339. 分裂二叉树的最大乘积](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/description/)

> **日期**：2026-01-07  
> **所用时间**：13min  
> **知识点**：二叉树、深度优先搜索

## 1. 题目描述

给你一棵二叉树，请你将二叉树拆分成两个子树，使得这两个子树的节点值之和的乘积最大。你可以选择任何一个非叶子节点，将它的左子树或右子树剪掉，将原树分裂为两棵子树。

请返回可以得到的最大乘积对 10^9+7 取余的结果。

**示例：**

输入：root = [1, 2, 3, 4, 5, 6]
输出：110

可视化如下二叉树结构：

```
        1
       / \
      2   3
     / \   \
    4   5   6
```

断开 1-2 红色边后的两棵子树:

```
树1:       树2:
   2         1
  / \         \
 4   5         3
                 \
                  6
```
节点和分别为 11 和 10，乘积为 110。

**提示：**
- 二叉树最多有 5 * 10^4 个节点
- 每个节点的值都在 [1, 10^4] 之间

## 2. 深度优先搜索

这道题的核心在于任意断掉一条边，会得到两棵子树，设一棵子树和为 $x$，则另一棵为 $sum - x$，我们要求 $x \times (sum-x)$ 的最大值。

步骤分析：
1. **整棵树的总和**  
    先通过一次 DFS 计算整棵树所有节点的和 $sum$。

2. **枚举每条可能断开的边**  
    在遍历二叉树的过程中，任意一个子树（即某个节点和它下方所有节点），都可以是断开的一个部分，剩下的就是 $sum -$ 这个子树的和。对每个节点递归返回其子树和，并在过程中计算最大乘积。

3. **保存最大乘积**  
    对每一个分割点（即每个子树），更新最大乘积。

注意点：

- DFS 两次：第一次求总和，第二次枚举每个分割点。
- 最终结果对 $10^9 + 7$ 取模。
- 若只有一个节点，无法分割，乘积为 0。

复杂度分析：

- 时间复杂度: $O(n)$ ，每个节点只访问一次
- 空间复杂度: $O(1)$

**Python3**

```python
class Solution:
    def maxProduct(self, root: Optional[TreeNode]) -> int:
        ans = s = 0

        def dfs(root):
            nonlocal ans
            
            res = root.val
            if root.left:
                left_sum = dfs(root.left)
                res += left_sum
                ans = max(ans, left_sum * (s - left_sum))
            if root.right:
                right_sum = dfs(root.right)
                res += right_sum
                ans = max(ans, right_sum * (s - right_sum))
            return res

        s = dfs(root)
        dfs(root)
        return ans % int(1e9 + 7)
```