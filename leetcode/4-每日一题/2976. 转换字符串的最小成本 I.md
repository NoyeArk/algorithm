# [2976. 转换字符串的最小成本 I](https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/description/)

> **日期**：2026-01-30  
> **所用时间**：20min  
> **知识点**：弗洛伊德算法

## 1. 题目描述

给你两个下标从 0 开始的字符串 source 和 target ，它们的长度均为 n 并且由 小写 英文字母组成。

另给你两个下标从 0 开始的字符数组 original 和 changed ，以及一个整数数组 cost ，其中 cost[i] 代表将字符 original[i] 更改为字符 changed[i] 的成本。

你从字符串 source 开始。在一次操作中，如果 存在 任意 下标 j 满足 cost[j] == z  、original[j] == x 以及 changed[j] == y 。你就可以选择字符串中的一个字符 x 并以 z 的成本将其更改为字符 y 。

返回将字符串 source 转换为字符串 target 所需的 最小 成本。如果不可能完成转换，则返回 -1 。

注意，可能存在下标 i 、j 使得 original[j] == original[i] 且 changed[j] == changed[i] 。

## 2. 弗洛伊德算法

1. **字符映射建图（邻接矩阵）**  
   把 a~z 全部看成点，给定的转换规则就是带边权的有向边（多条规则保留最小代价）。

2. **Floyd 算法求最短路**  
   如果要把 x 变成 y，可能要中间经过很多步，所以用 Floyd 求所有点对最小转换代价。

3. **累加答案**  
   遍历 source, target 同位，如果 source[i]==target[i]，不用变，否则查最短路矩阵中最小代价累加到答案。若有某位无法转换（最小代价仍为 inf），直接返回 -1。

复杂度分析：

- 时间复杂度：O(26^3 + n)
- 空间复杂度：O(26^2)

**Python3**

```python
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        dis = [[inf] * 26 for _ in range(26)]
        for i in range(26):
            dis[i][i] = 0

        for x, y, c in zip(original, changed, cost):
            x = ord(x) - ord('a')
            y = ord(y) - ord('a')
            dis[x][y] = min(dis[x][y], c)
        
        for k in range(26):
            for i in range(26):
                if dis[i][k] == inf:
                    continue
                for j in range(26):
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])

        ans = sum(dis[ord(x) - ord('a')][ord(y) - ord('a')] for x, y in zip(source, target))
        return ans if ans < inf else -1
```