# [2410. 运动员和训练师的最大匹配数](https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/description/)

> **日期**：2025-07-13
> **所用时间**：5min

## 1. 贪心

### 题目描述

有一组运动员和一组训练师，每个运动员有一个能力值，每个训练师有一个训练能力。若某个运动员的能力值小于等于某个训练师的训练能力，则该运动员可以和该训练师匹配。每个运动员和训练师最多只能匹配一次。问最多能匹配多少对。

### 解题思路

本题是典型的**贪心**匹配问题。我们希望让尽可能多的运动员被匹配上。具体做法如下：

1. **排序**：先将`players`和`trainers`数组从小到大排序。
2. **双指针**：用两个指针`i`和`j`分别指向当前未匹配的运动员和训练师。
3. **遍历匹配**：
    - 如果当前运动员`players[i]`的能力值小于等于当前训练师`trainers[j]`的训练能力，则匹配成功，两个指针都后移，匹配数加一。
    - 否则，说明当前训练师无法匹配当前运动员，需要让训练师指针后移，寻找能力更强的训练师。
4. **终止条件**：只要有一方遍历完就结束。

这种贪心策略保证了每个运动员都尽量用能力最接近的训练师去匹配，从而最大化匹配数。

#### 例子

- `players = [4,7,9]`
- `trainers = [8,2,5,8]`

排序后：
- `players = [4,7,9]`
- `trainers = [2,5,8,8]`

匹配过程：
- 4 vs 2（不行），训练师后移
- 4 vs 5（可以），匹配，i=1, j=2, ans=1
- 7 vs 8（可以），匹配，i=2, j=3, ans=2
- 9 vs 8（不行），训练师后移
- 9 vs 8（不行），训练师后移，结束

最终答案为2。

### 复杂度分析

- 时间复杂度：排序$O(n\log n + m\log m)$，遍历$O(n+m)$，总共$O(n\log n + m\log m)$。
- 空间复杂度：$O(1)$（原地排序）。

**Python3**

```python
class Solution:
    def matchPlayersAndTrainers(self, players: List[int], trainers: List[int]) -> int:
        players.sort()
        trainers.sort()

        ans = i = j = 0
        while i < len(players) and j < len(trainers):
            if players[i] <= trainers[j]:
                i += 1
                j += 1
                ans += 1
            else:
                j += 1
        return ans
```