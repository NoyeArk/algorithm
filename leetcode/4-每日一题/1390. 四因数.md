# [1390. 四因数](https://leetcode.cn/problems/four-divisors/description/)

> **日期**：2026-01-04  
> **所用时间**：10min  
> **知识点**：数学、枚举、因式分解

## 1. 因数分解

对于较大的数，只需要遍历到 $\sqrt{x}$ 即可，因为如果 $x$ 有因数 $i$，那么 $x$ 也一定有因数 $x/i$。

如果因子个数大于4，则直接跳过，因为一个数最多只有4个因子。

如果因子个数为4，则将因子相加，最后返回结果。

复杂度分析：

- 时间复杂度：$O(n \sqrt{x})$，其中 $n$ 是数组的长度，$x$ 是数组中的最大值。
- 空间复杂度：$O(1)$。

**Python3**

```python
class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        ans = 0

        for x in nums:
            factors = set()
            for i in range(1, int(math.isqrt(x)) + 1):
                if x % i == 0:
                    factors.add(i)
                    factors.add(x // i)
                    if len(factors) > 4:
                        break
            if len(factors) == 4:
                ans += sum(factors)
        return ans
```

## 2. 预处理每个数的因数个数和因数之和

因数组最大值较小（如 $\leq 10^5$），可以预处理每个数的因数个数与因数和。

- 对每一个 $i$，遍历其所有倍数 $j$，对 $j$ 的因数个数和因数和分别累加。
- 最终查表即可：如果一个数的因数个数为 $4$，则累加该数的因数和。

复杂度分析：

- 时间复杂度： $O(n)$，其中 $n$ 是 $nums$ 的长度
- 空间复杂度： $O(1)$

设 $U=max(nums)$ ，预处理的时间为 $O(UlogU)$（调和级数和），空间为 $O(U)$，不计入。

**Python3**

```python
MX = 100_001
divisor_num = [0] * MX
divisor_sum = [0] * MX
for i in range(1, MX):
    for j in range(i, MX, i):
        divisor_num[j] += 1
        divisor_sum[j] += i

class Solution:
    def sumFourDivisors(self, nums: List[int]) -> int:
        ans = 0
        for x in nums:
            if divisor_num[x] == 4:
                ans += divisor_sum[x]
        return ans
```