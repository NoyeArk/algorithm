# [955. 删列造序 II](https://leetcode.cn/problems/delete-columns-to-make-sorted-ii/description/)

> **日期**：2025-12-21
> **所用时间**：27min
> **知识点**：字符串、贪心

## 1. 贪心

本题属于**列删除-字典序有序问题**的升级版，即不仅要保证每一列单独删除后整体有序，还要考虑删除的**最小列数**，使得各行字典序**整体非递减**。

### 题意简述

给定 $m$ 个长度为 $n$ 的小写字母等长字符串，把它们**每一列视为字符数组的同一位**，允许你删除任意列，使得删后剩下的字符串数组**按字典序非递减**，问最少需要删掉多少列。

- $m, n \leq 100$

### （1）枚举每一列，判断能否保留

核心思想是：**能不删除就不删除，但一旦遇到未保证顺序的列冲突，就必须删掉该列**。

- 设 $sorted\_flag$ 数组，表示哪些相邻行已经通过前面的某些列确认顺序，即[i]为True表示第i行和第i+1行之间字典序已经确定。
- 遍历所有列，对于每一列：
  - 检查在“尚未确定顺序”的所有相邻行对 $(i, i+1)$，如果发现 $strs[i][col] > strs[i+1][col]$，**无论以前如何，这一列都必须删**，否则无法保证全局字典序。
  - 如果该列可保留，则再检查哪些相邻行对本列刚好构成 $strs[i][col] < strs[i+1][col]$，用以标记 sorted_flag[i]=True（即这些行对排序已确定，无需后续继续管）。
  - 如果所有相邻行已按字典序排好序，可提前 break，后面不用再判。

### （2）复杂度分析

- 每一列至多遍历 $O(m)$ 行对，因此总复杂度 $O(nm)$。

### （3）举例说明（以样例）

输入：
```
["ca","bb","ac"]
```
过程：
- col=0: ["c","b","a"]。发现 c > b（第1行对），需删掉第0列。
- col=1: ["a","b","c"]。a < b，b < c，所有行对排序已定，不用再判。
最终，只删了一列。

### （4）总结

- 只要某列会直接导致当前还无序的相邻行对逆序，就必须删。
- 保留的列要尽早“锁定”哪些行对顺序已定。
- 优化：如果所有行对都锁定，下游列可提前跳过。

**Python3**

```python
class Solution:
    def minDeletionSize(self, strs: List[str]) -> int:
        m, n = len(strs), len(strs[0])
        ans = 0
        sorted_flag = [False] * (m - 1)  # 相邻字符串(i, i+1)之间是否已经有字典序严格递增

        for col in range(n):
            # 检查本列能否保留
            need_del = False
            for i in range(m - 1):
                if not sorted_flag[i] and strs[i][col] > strs[i+1][col]:
                    need_del = True
                    break

            if need_del:
                ans += 1
                continue

            # 可以保留本列，再更新相邻字符串对的有序状态
            for i in range(m - 1):
                if not sorted_flag[i] and strs[i][col] < strs[i+1][col]:
                    sorted_flag[i] = True
            
            # 如果所有的相邻字符串已经有序，可直接结束
            if all(sorted_flag):
                break
        return ans
```