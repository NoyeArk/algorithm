# [799. 香槟塔](https://leetcode.cn/problems/champagne-tower/)

> **日期**：2026-02-14  
> **所用时间**：12min  
> **知识点**：动态规划、模拟

## 1. 题目描述

玻璃杯摆成金字塔形：第 1 层 1 个杯，第 2 层 2 个，……，第 100 层 100 个。每个杯子容量为 1 单位。从最顶层唯一的杯子开始倒香槟；当某杯装满（≥1）后，**多出的部分会均分**流入下一层**左右相邻**的两只杯（各占一半）。若下层杯也满则继续向下层流，多出的流到地面。给定倾倒总量 `poured` 以及查询位置 `query_row`、`query_glass`，求该位置杯子中香槟的**填满比例**（0～1，超过 1 视为 1）。

**示例 1：**

```
输入：poured = 1, query_row = 1, query_glass = 1
输出：0.00000
解释：顶层一杯满后无溢出，第二层两杯均为 0。
```

**示例 2：**

```
输入：poured = 2, query_row = 1, query_glass = 1
输出：0.50000
解释：顶层满后溢出 1 单位，各 0.5 流入第二层两个杯子，故 (1,1) 为 0.5。
```

**示例 3：**

```
输入：poured = 100000009, query_row = 33, query_glass = 17
输出：1.00000
解释：倾倒量很大，查询位置杯子满杯。
```

**提示：**

- `0 <= poured <= 10^9`
- `0 <= query_glass <= query_row < 100`

## 2. 逐层 DP 模拟

用 `f[i][j]` 表示**流经**第 i 行第 j 杯的香槟总量（可大于 1）。

初始 `f[0][0] = poured`。对每一行、每一杯：

1. 若 `f[i][j] > 1`，则溢出 `(f[i][j] - 1) / 2` 分别加到 `f[i+1][j]` 与 `f[i+1][j+1]`。
2. 只需递推到 `query_row` 行，答案为 `min(1.0, f[query_row][query_glass])`。

复杂度分析：

- **时间复杂度**：$O((\textit{query\_row})^2)$  
- **空间复杂度**：$O((\textit{query\_row})^2)$

**Python3**

```python
class Solution:
    def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
        # f[i][j] 表示流经第 i 行第 j 杯的香槟总量（可大于 1，大于 1 的部分会溢出）
        f = [[0.0] * (query_row + 2) for _ in range(query_row + 2)]
        f[0][0] = poured
        for i in range(query_row + 1):
            for j in range(i + 1):
                if f[i][j] <= 1:
                    continue
                overflow = (f[i][j] - 1) / 2
                f[i + 1][j] += overflow
                f[i + 1][j + 1] += overflow
        return min(1.0, f[query_row][query_glass])
```