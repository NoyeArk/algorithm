# [868. 二进制间距](https://leetcode.cn/problems/binary-gap/description/)

> **日期**：2026-02-22  
> **所用时间**：5min  
> **知识点**：位运算、模拟

## 1. 题目描述

给定一个正整数 `n`，返回 `n` 的二进制表示中两个**相邻**的 1 之间的**最长距离**。如果不存在两个相邻的 1，返回 `0`。

**两个 1 之间的距离**定义为它们在二进制串中下标的差的绝对值。例如 `"1001"` 里两个 1 的下标差为 3，距离即为 3。

**示例 1：**

```
输入：n = 22
输出：2
解释：22 的二进制是 "10110"，第一对 1 距离为 2，第二对距离为 1，答案为 2。
```

**示例 2：**

```
输入：n = 5
输出：2
解释：5 的二进制是 "101"，两个 1 距离为 2。
```

**示例 3：**

```
输入：n = 8
输出：0
解释：8 的二进制是 "1000"，没有两个相邻的 1。
```

**提示：**

- `1 <= n <= 10^9`

## 2. 模拟

遍历 `n` 的二进制表示中的每一位（可转为字符串或用位运算逐位检查），记录**上一枚 1 的下标**；每当遇到新的 1，用「当前下标 - 上一枚下标」更新最大间距。若从未出现两枚 1 则答案为 0。

- 时间复杂度：$O(n)$ 其中 $n$ 是 $n$ 的二进制表示的位数
- 空间复杂度：$O(1)$

**Python3**

```python
class Solution:
    def binaryGap(self, n: int) -> int:
        ans = 0
        pos = inf

        for i, c in enumerate(str(bin(n))):
            if c == '1':
                ans = max(ans, i - pos)
                pos = i
        return ans
```

## 3. 位运算

位运算的方法相比字符串遍历更高效且空间占用低。思路为：我们可以用位运算依次寻找每一个 `1`，并计算相邻 `1` 之间的距离。

基本步骤如下：

1. 利用 `n & -n` 可以提取出最低位的 `1`，即二进制中最右边的 `1`。
2. 计算当前最低位 `1` 到下一个最低位 `1` 相隔多少位（即两个 `1` 之间有多少个 `0`），这个距离就是两枚 `1` 的下标差。
3. 每次把 `n` 右移到下一个 `1`（用 `n >>= gap`）继续处理，直到所有的 `1` 都被处理完。
4. 答案取所有间距中的最大值。

例如 `n = 22`（"10110"），两对相邻的 `1` 的间距分别为 2 和 1，最大为 2，符合题意。

复杂度分析：

- 时间复杂度：$O(k)$ 其中 $k$ 是 $n$ 的二进制表示中 $1$ 的个数
- 空间复杂度：$O(1)$

**Python3**

```python
class Solution:
    def binaryGap(self, n: int) -> int:
        ans = 0
        n >>= (n & -n).bit_length()

        while n:
            gap = (n & -n).bit_length()
            ans = max(ans, gap)
            n >>= gap
        return ans
```