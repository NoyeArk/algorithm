# [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/description/)

> **日期：** 2026-01-11  
> **所用时间：** 22min  
> **知识点：** 单调栈

## 1. 题目描述

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形面积。

示例 1:

输入:
```
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
```
输出:
```
6
```

## 2. 单调栈

### 题解思路

本题结合了**单调栈**与**直方图最大矩形面积**的经典模型来求解矩阵中最多全为 1 的子矩形面积。

#### 步骤 1：将问题转化为「若干个直方图求最大矩形面积」

对于每一行，考虑这一行为底边向上的所有`1`的连续数目，就可以将矩阵每一行看作一个直方图的底边，高度为连续的1的数量。
- 如果当前位置为`'1'`，则高度在上一行的基础上加1
- 如果位置为`'0'`，高度置为0

这样，遍历矩阵的每一行，都得到一个“直方图”，对于每一行，直接求直方图最大矩形。

#### 步骤 2：单调栈求直方图最大矩形面积

对于每一次的直方图，使用单调栈来维护递增的高度。当遇到较小的高度时，可以不断出栈并做面积计算，确定以某个高度为最低的最大宽度。具体实现中会在头尾各补一个0，简化边界处理。

#### 代码核心

- `heights` 记录到当前行为止每一列的“高度”
- 对于每一行，更新 `heights`，调用单调栈函数计算本层最大矩形面积，与全局面积更新

#### 复杂度分析

- 时间复杂度：$O(n \times m)$，每行 $O(m)$，每列 $O(n)$。
- 空间复杂度：$O(m)$，单调栈与高度数组长度和列数m一致。

此思路通用且高效，适合处理各类最大全1子矩形问题。

**Python3**

```python
class Solution:
    def maximalRectangle(self, matrix: List[List[str]]) -> int:
        def largestRectangleArea(heights: List[int]) -> int:
            new_heights = [0] + heights + [0]
            stk = []
            ans = 0
            for i, h in enumerate(new_heights):
                while stk and h < new_heights[stk[-1]]:
                    dh = new_heights[stk.pop()]
                    dw = i - stk[-1] - 1
                    ans = max(ans, dh * dw)
                stk.append(i)
            return ans

        heights = [0] * len(matrix[0])
        ans = 0
        for row in matrix:
            for i, c in enumerate(row):
                heights[i] = 0 if c == '0' else heights[i] + 1
            ans = max(ans, largestRectangleArea(heights))
        return ans
```