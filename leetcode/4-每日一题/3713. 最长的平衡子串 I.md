# [3713. 最长的平衡子串 I](https://leetcode.cn/problems/longest-balanced-substring-i/description/)

> **日期**：2025-02-08  
> **所用时间**：10min  
> **知识点**：枚举、哈希表

## 1. 题目描述

给定一个字符串 `s`，请找出其中最长的**平衡子串**的长度。

**平衡子串**的定义：子串中所有出现过的字符，出现次数都相同。

例如：
- `"ab"`、`"aabb"`、`"abc"`、`"aabbcc"` 都是平衡的（每种字符出现次数相等）；
- `"aab"` 不是平衡的（a 出现 2 次，b 出现 1 次）。

**约束：**
- `1 <= s.length <= 100`
- `s` 仅由小写英文字母组成

**示例 1：**

```
输入：s = "abc"
输出：3
解释：整个串 "abc" 中 a、b、c 各出现 1 次，是平衡的，长度为 3。
```

**示例 2：**

```
输入：s = "aabb"
输出：4
解释："aabb" 中 a 和 b 各出现 2 次，是平衡的，长度为 4。
```

**示例 3：**

```
输入：s = "aaa"
输出：1
解释：仅一种字符时，可视为出现次数相同，最长平衡子串长度为 1。
```

## 2. 枚举子串 + 哈希表计数

枚举所有子串 `s[i..j]`，用哈希表统计每种字符的出现次数；若所有出现过的字符次数相同（即 `cnts` 中所有 value 相等），则用该子串长度更新答案。初始答案至少为 1（单字符子串一定平衡）。

复杂度分析：
- **时间复杂度**：$O(n^2)$，枚举左右端点并统计。
- **空间复杂度**：$O(|\Sigma|)$，为字符计数所用哈希表，字母集大小可视为常数。

**Python3**

```python
class Solution:
    def longestBalanced(self, s: str) -> int:
        ans = 1
        n = len(s)

        for i in range(n):
            cnts = defaultdict(int)
            for j in range(i, n):
                cnts[s[j]] += 1
                if len(set(cnts.values())) == 1:
                    ans = max(ans, j - i + 1)
        return ans
```
