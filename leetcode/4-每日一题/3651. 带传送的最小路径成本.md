# [3651. 带传送的最小路径成本](https://leetcode.cn/problems/minimum-cost-to-make-all-paths-lead-to-the-city-zero/description/)

> **日期**：2026-01-28  
> **所用时间**：48min  
> **知识点**：动态规划

## 1. 动态规划

### 题意简述

给你一个 $m \times n$ 的网格 grid，每个格子有花费 grid[i][j]。你每次可以从左上角出发，只能向下或向右走到终点右下角。你还可以使用至多 $k$ 次传送，每次传送可以让你瞬间从某个格子跳到另一个格子（代价就是目的地格子的 grid 值），且本次传送的前置条件是「上一次未被访问的格子代价的最小前缀/后缀」（动态规划转移依赖于花费最小前缀/后缀）。

### 思路分析

- 状态设计：用 $f[i][j]$ 表示到 $(i,j)$ 最小花费，传送次数用前缀最小/后缀最小数组维护。每次可不传送（常规 DP），也可以传送到任意点（依赖传送前的最小花费）。
- 关键难点：如何高效转移传送（即用 k+1 次维度滚动数组，和前缀/后缀最小辅助数组）。
- 朴素做法会超时，需要用「按权值合并」和「传送跳跃」优化状态转移，具体见下方核心代码。

### 步骤

1. 初始化，f[0][1] 和 f[1][0] 设成 $-grid[0][0]$，其余无穷大。
2. 枚举传送次数 $0 \ldots k$，每次用 min_f 维护当前权值下最小代价。
3. 常规 DP：向右/下转移，或用 suf_min_f（上一次传送状态），任选最优。
4. 用后缀前缀维护 suf_min_f 优化转移。
5. 最终输出终点 $(m,n)$ 的最小花费。

### 复杂度分析：

- 时间复杂度：状态转移 $O((k+1) \cdot (m \cdot n + mx))$，$mx$ 为 grid 最大值，用空间换时间。
- 空间复杂度： $O(m \cdot n + mx)$

**Python3**

```python
class Solution:
    def minCost(self, grid: List[List[int]], k: int) -> int:
        m, n = len(grid), len(grid[0])
        mx = max(map(max, grid))

        suf_min_f = [inf] * (mx + 2)
        f = [[inf] * (n + 1) for _ in range(m + 1)]
        f[0][1] = f[1][0] = -grid[0][0]

        for _ in range(k + 1):
            min_f = [inf] * (mx + 1)

            for i, row in enumerate(grid):
                for j, x in enumerate(row):
                    f[i + 1][j + 1] = min(f[i + 1][j] + x, f[i][j + 1] + x, suf_min_f[x])
                    min_f[x] = min(min_f[x], f[i + 1][j + 1])
            
            for i in range(mx, -1, -1):
                suf_min_f[i] = min(suf_min_f[i + 1], min_f[i])

        return f[m][n]
```