# [1680. 连接连续二进制数字](https://leetcode.cn/problems/concatenation-of-consecutive-binary-numbers/description/)

> **日期**：2025-02-06  
> **所用时间**：10min  
> **知识点**：位运算、模拟、数学

## 1. 题目描述

给定一个整数 `n`，将 `1` 到 `n` 的二进制表示**按顺序连接**成一个二进制字符串，返回该二进制串对应的**十进制值**并对 $10^9 + 7$ **取模**的结果。

**示例 1：**

- **输入**：n = 1  
- **输出**：1  
- **解释**：只有数字 1，二进制为 `"1"`，十进制值为 1。

**示例 2：**

- **输入**：n = 3  
- **输出**：27  
- **解释**：1、2、3 的二进制分别为 `"1"`、`"10"`、`"11"`，连接后为 `"11011"`，对应十进制 $1 \times 2^4 + 1 \times 2^3 + 0 \times 2^2 + 1 \times 2^1 + 1 \times 2^0 = 27$。

**示例 3：**

- **输入**：n = 12  
- **输出**：505379714  
- **解释**：连接得到的二进制串很长，其十进制值对 $10^9 + 7$ 取模后为 505379714。

**约束：**

- $1 \le n \le 10^5$

---

## 2. 「位运算 / 模拟」

**思路：**

- **方法一（模拟拼接）**：从 1 到 n 遍历，把每个数的二进制去掉前导 `"0b"` 后拼成一个字符串，最后用 `int(s, 2)` 转成十进制再对 $10^9+7$ 取模。实现简单，但字符串会很长，时间和空间都偏大。
- **方法二（位运算）**：不显式构造字符串。维护当前结果 `ans`，对每个 $i$，把 `ans` 左移 `i.bit_length()` 位（为 $i$ 的二进制腾出位置），再与 $i$ 做按位或，即 `ans = (ans << i.bit_length() | i) % mod`。这样每次都是在“二进制串末尾”接上 $i$ 的二进制表示，等价于题目要求的连接，且无需字符串，空间 $O(1)$。

**复杂度分析：**

- 时间复杂度：$O(n)$（遍历 1 到 n，每次位运算与取模为 $O(1)$）
- 空间复杂度：方法一 $O(n \log n)$（字符串长度），方法二 $O(1)$

**Python3**

```python
class Solution:
    def concatenatedBinary(self, n: int) -> int:
        s = ""
        for i in range(1, n + 1):
            s += bin(i)[2:]
        return int(s, 2) % int(1e9 + 7)
```

**Python3**

```python
class Solution:
    def concatenatedBinary(self, n: int) -> int:
        ans = 0
        for i in range(1, n + 1):
            ans = (ans << i.bit_length() | i) % int(1e9 + 7)
        return ans
```