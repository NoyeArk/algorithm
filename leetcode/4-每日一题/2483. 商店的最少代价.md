# [2483. 商店的最少代价](https://leetcode.cn/problems/minimum-penalty-for-a-shop/description/)

> **日期:** 2025-12-26
> **所用时间:** 15min
> **知识点:** 前缀和、枚举

## 1. 一次遍历

本题可以枚举关门时间 $i$，计算每个时刻的总代价，选择最小的那个。

惩罚的具体计算方式：

- 在 $[0,\,i-1]$，对所有 `'N'` 计 1 次惩罚（因为这段时间商店开门，遇到 `'N'` 视为 "白开门"）；
- 在 $[i,\,n-1]$，对所有 `'Y'` 计 1 次惩罚（因为这段时间商店关门，遇到 `'Y'` 视为“白关门”）。

我们可以利用前缀和思想优化，边遍历边计算。

实现细节：

1. 先统计字符串中 `'Y'` 的总数 `cnt_y`。
2. 从左到右枚举每个关门时间 $i$（$0$ 到 $n$），维护当前前缀 `'N'` 的个数 `cur_n`。
3. 每次计算：
   - `cur_n`：前 $i$ 项 `'N'` 的数量（"早关门带来的惩罚"）
   - `cnt_y - cur_y`：后缀（$[i,\,n-1]$）中 `'Y'` 的数量（"晚关门带来的惩罚"），其中 `cur_y = i - cur_n` 是截至 $i$ 前 `'Y'` 的数量。
   - 总惩罚为两者之和。
4. 取惩罚最小的那个 $i$。

复杂度分析：

- 时间复杂度：$O(n)$，逐一遍历每个位置。
- 空间复杂度：$O(1)$，只用常数变量。

**Python3**

```python
class Solution:
    def bestClosingTime(self, customers: str) -> int:
        mi = n = len(customers)
        cnt_y = sum(c == 'Y' for c in customers)
        cur_n = ans = 0

        for i in range(n + 1):
            cur_y = i - cur_n
            if mi > cur_n + cnt_y - cur_y:
                ans = i
                mi = cur_n + cnt_y - cur_y
            cur_n = cur_n + 1 if i < n and customers[i] == 'N' else cur_n
        return ans
```
