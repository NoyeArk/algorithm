# [1356. 根据数字二进制下 1 的数目排序](https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits/description/)

> **日期**：2026-02-25  
> **所用时间**：1min  
> **知识点**：排序、位运算

## 1. 题目描述

给你一个整数数组 `arr`。请你将数组中的元素按照其二进制表示中数字 **1** 的数目升序排序。

若存在多个数字二进制中 **1** 的数目相同，则必须将它们按照数值大小升序排列。

请你返回排序后的数组。

**示例 1：**

- **输入**：arr = [0,1,2,3,4,5,6,7,8]
- **输出**：[0,1,2,4,8,3,5,6,7]
- **解释**：二进制中 1 的个数分别为 0,1,1,2,1,2,2,3,1，按个数排序后再按数值排序得到 [0,1,2,4,8,3,5,6,7]。

**示例 2：**

- **输入**：arr = [1024,512,256,128,64,32,16,8,4,2,1]
- **输出**：[1,2,4,8,16,32,64,128,256,512,1024]

**提示：**

- `1 <= arr.length <= 500`
- `0 <= arr[i] <= 10^4`

## 2. 排序

自定义排序：以「二进制中 1 的个数」为第一关键字升序，「数值」为第二关键字升序。Python 中可用 `sorted(arr, key=lambda x: (x.bit_count(), x))`，其中 `bit_count()` 为 Python 3.10+ 内置方法；

若环境不支持 `bit_count()` 方法，可用 `bin(x).count('1')` 替代。

复杂度分析：

- 时间复杂度：$O(n\log n)$，其中 $n$ 为数组长度，排序主导。
- 空间复杂度：$O(\log n)$，排序栈空间（若不计返回数组）。

**Python3**

```python
class Solution:
    def sortByBits(self, arr: List[int]) -> List[int]:
        return sorted(arr, key=lambda x: (x.bit_count(), x))
```