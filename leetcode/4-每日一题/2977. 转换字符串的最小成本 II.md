# [2977. 转换字符串的最小成本 II](https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/description/)

> **日期**：2026-01-30  
> **所用时间**：20min  
> **知识点**：弗洛伊德算法、记忆化搜索

## 1. 题目描述

## 2. 题解

本题和「2976. 转换字符串的最小成本 I」的区别在于：  

- 允许 `original[i]` 和 `changed[i]` 为字符串（子串），即一次可以将一段字符串整体替换为另一段字符串，而非仅限于单字符替换。

因此，直接用弗洛伊德算法求所有字符间的最短路已不适用。需要结合**字符串的分段匹配**和**动态规划（记忆化搜索）**。

### 主要思路

1. **建图**  
   - 用字典 `dis` 记录所有替换规则及其成本，`dis[x][y]` 表示把字符串 `x` 替换为字符串 `y` 的最小代价。
   - 对所有替换规则，保留代价最小的。

2. **多段最短路**  
   - 虽然不是单字符替换，但如果存在多步替换（如 A → B → C），就可以对节点（字符串）应用 Floyd 算法求传递闭包以合成更优的替换序列。

3. **记忆化搜索 + 匹配子串**  
   - 定义 dp(i)：source 待处理区间为 [i, n-1]，变为 target 区间的最小代价。
   - 搜索时，既可以选择当前位置不变（若 `source[i] == target[i]`），也可以匹配任意一段长度的 source[i:i+len(s)]，用替换规则试图将其替换为 target[i:i+len(s)]，累加花费并递归。
   - 用 cache 装饰器记忆化，避免重复计算。

4. **剪枝与终止条件**  
   - 若无法找到合理的替换，或最终花费为无穷大，返回 -1。

### 代码实现要点

- 利用 defaultdict 构造多层字典，简洁地管理字符串间的映射关系及花费。
- nodes 集合记录所有出现过的字符串节点，减少无意义的枚举。
- 记忆化 (cache) 优化递归效率。
- 两重循环做基于字符串的 Floyd 算法，确保间接转换路径的最优性。

### 复杂度分析

- 设 source/target 长度为 n，规则数为 m，最短路节点总数为 k。
- 最坏 dp 状态数 O(n)，每次需枚举 k 个规则，合并复杂度 O(nk)。
- Floyd 传递闭包 O(k^3)，但由于 k 实际通常远小于 n^2，实际较快。

```python
class Solution:
    def minimumCost(self, source: str, target: str, original: List[str], changed: List[str], cost: List[int]) -> int:
        dis = defaultdict(lambda: defaultdict(lambda: inf))
        nodes = set()
        for x, y, c in zip(original, changed, cost):
            dis[x][y] = min(dis[x][y], c)
            dis[x][x] = dis[y][y] = 0
            nodes.add(x)
            nodes.add(y)
        
        for k in nodes:
            for i in nodes:
                if dis[i][k] == inf:
                    continue
                for j in nodes:
                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j])
        
        @cache
        def dfs(i):
            if i >= len(source):
                return 0
            
            res = inf
            if source[i] == target[i]:
                res = dfs(i + 1)

            for s, ne in dis.items():
                if source[i:i+len(s)] == s and target[i:i+len(s)] in ne:
                    res = min(res, ne[target[i:i+len(s)]] + dfs(i+len(s)))
            return res
        
        ans = dfs(0)
        return ans if ans < inf else -1
```