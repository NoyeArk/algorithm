# [1653. 使字符串平衡的最少删除次数](https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced/description/)

> **日期**：2026-02-08  
> **所用时间**：10min  
> **知识点**：动态规划、字符串

## 1. 题目描述

给定一个仅由字符 `'a'` 和 `'b'` 组成的字符串 `s`。删除若干字符使得字符串**平衡**。

平衡字符串定义为：字符串中不存在一个 `'b'` 在 `'a'` 之前。即所有 `'a'` 必须在所有 `'b'` 之前，形如 `a...a b...b`。

请返回使字符串平衡的**最少删除次数**。

**示例 1：**
```
输入：s = "aababbab"
输出：2
解释：可以删除下标 2 和 6 的 'b'，得到 "aaabab"；或删除下标 3 和 6 的 'b'，得到 "aabbaa"。都是平衡字符串。
```

**示例 2：**
```
输入：s = "bbaaaaabb"
输出：2
解释：删除前两个 'b'，得到 "aaaaabb"。
```

## 2. 解题算法

### 2.1 算法思路

等价于求**保留的最长平衡子序列**，答案 = $n - \max(\text{保留长度})$。

平衡子序列形如 `a*a*b*b*`，用 DP 维护：
- `last_a`：以 `'a'` 结尾的最长平衡子序列长度
- `last_b`：以 `'b'` 结尾的最长平衡子序列长度

遍历每个字符：
- 遇到 `'a'`：只能接在 `last_a` 后面（`'a'` 必须在 `'b'` 前）
- 遇到 `'b'`：可接在 `last_a` 或 `last_b` 后面

最终答案为 $n - \max(\text{所有状态})$。

### 2.2 复杂度分析

- **时间复杂度**：$O(n)$，单次遍历字符串。
- **空间复杂度**：$O(1)$，仅使用常数个变量。

### 2.3 代码实现

**Python3**

```python
class Solution:
    def minimumDeletions(self, s: str) -> int:
        # f[i]表示以s[i]结尾满足要求的子串的最大长度

        n = len(s)
        f = [1] * n
        last_a = int(s[0] == 'a')
        last_b = int(s[0] == 'b')
        for i in range(1, n):
            if s[i] == 'a':
                f[i] += last_a
                last_a = f[i]
            else:
                f[i] += max(last_a, last_b)
                last_b = f[i]
        return n - max(f)
```