# [3479. 水果成篮 III](https://leetcode.cn/problems/fruits-into-baskets-iii/description/)

> **日期**：2026-01-14  
> **知识点**：线段树

## 1. 题目描述

给你两个长度为 $n$ 的整数数组，$fruits$ 和 $baskets$，其中 $fruits[i]$ 表示第 $i$ 种水果的 数量，$baskets[j]$ 表示第 $j$ 个篮子的 容量。

你需要对 $fruits$ 数组从左到右按照以下规则放置水果：

- 每种水果必须放入第一个 容量大于等于 该水果数量的 最左侧可用篮子 中。
- 每个篮子只能装 一种 水果。
- 如果一种水果 无法放入 任何篮子，它将保持 未放置。

返回所有可能分配完成后，剩余未放置的水果种类的数量。

**示例 1**：

输入： $fruits = [4,2,5]$, $baskets = [3,5,4]$

输出： $1$

解释：

- $fruits[0] = 4$ 放入 $baskets[1] = 5$。
- $fruits[1] = 2$ 放入 $baskets[0] = 3$。
- $fruits[2] = 5$ 无法放入 $baskets[2] = 4$。
由于有一种水果未放置，我们返回 1。

**示例 2**：

输入： $fruits = [3,6,1]$, $baskets = [6,4,7]$

输出： $0$

解释：

- $fruits[0] = 3$ 放入 $baskets[0] = 6$。
- $fruits[1] = 6$ 无法放入 $baskets[1] = 4$（容量不足），但可以放入下一个可用的篮子 $baskets[2] = 7$。
- $fruits[2] = 1$ 放入 $baskets[2] = 7$。

由于所有水果都已成功放置，我们返回 $0$。

## 2. 线段树

本题属于典型的区间动态查询与修改问题，适合用**线段树**高效地完成操作。

对于每一种水果，我们要把它放到从左到右第一个容量**大于等于它的、还未被使用的篮子**里。每个篮子只能用一次。无法放入的水果算作未放置。求最终未放置的水果种类数。

最朴素的做法是每放一个水果都线性找下可用篮子，但显然会 $TLE$。核心优化点是**如何高效地找第一个满足条件的篮子并将其标记为已用**。

用线段树维护最大值。每当前有水果 $x$ 时，从左到右找第一个区间最大值 $\geq x$ 的叶子节点，然后将其值设为 $-1$ （表示已用）。重复此操作。

- 线段树初始化：将 $baskets$ 作为底层数组建树，每个节点维护区间最大值。
- 查找+更新：找第一个 $\max \geq x$ 的位置并把其修改为 $-1$。

整个分配过程时间复杂度$O(n\log n)$，非常高效。

#### 代码精要

线段树有以下几个核心方法：

- `build`：递归建树，初始化每个节点最大值
- `find_first_and_update`：查找第一个最大值大于等于$x$的位置，并将其设为-1
- `maintain`：更新某个区间对应的最大值

主解法：

对fruits数组每个元素调用一次`find_first_and_update`，如果查找不到则未放置。

#### 复杂度分析

- 时间复杂度：$O(n\log n)$，$n$为数组长度
- 空间复杂度：$O(n)$

#### 总结

- 本题考查区间动态查询与修改，线段树是极佳的数据结构。
- 通过维护区间最大值，能高效实现从左到右第一个符合条件元素的查找与修改。

**Python3**

```python
class SegmentTree:
    def __init__(self, nums):
        n = len(nums)
        self.max = [0] * (2 << (n - 1).bit_length())
        self.build(nums, 1, 0, n - 1)
    
    def build(self, nums, o, l, r):
        if l == r:
            self.max[o] = nums[l]
            return 
        m = (l + r) >> 1
        self.build(nums, o * 2, l, m)
        self.build(nums, o * 2 + 1, m + 1, r)
        self.maintain(o)
    
    def maintain(self, o):
        self.max[o] = max(self.max[o * 2], self.max[o * 2 + 1])
    
    def find_first_and_update(self, o, l, r, x):
        if self.max[o] < x:
            return -1
        if l == r:
            self.max[o] = -1
            return l
        m = (l + r) >> 1
        i = self.find_first_and_update(o * 2, l, m, x)
        if i < 0:
            i = self.find_first_and_update(o * 2 + 1, m + 1, r, x)
        self.maintain(o)
        return i


class Solution:
    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -> int:
        t = SegmentTree(baskets)
        n = len(baskets)
        ans = 0
        for x in fruits:
            if t.find_first_and_update(1, 0, n - 1, x) < 0:
                ans += 1
        return ans
```