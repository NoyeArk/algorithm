# [3652. 按策略买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-using-strategy/description/)

> **日期**：2025-12-21
> **所用时间**：20min
> **知识点**：滑动窗口、前缀和

## 1. 滑动窗口 + 前缀和

### 题目简述

已知股票价格数组 `prices`，买卖策略数组 `strategy`（每个位置为 `1` 表示该天建议买入，为 `-1` 表示建议卖出，为 `0` 表示不操作），以及一个正整数窗口长度 $k$。问：如何通过**按照 `strategy` 执行买卖**外，还考虑**恰好对于一段长度为 $k$ 的子数组，改变操作方案（即换成贪心买入/卖出）**，以获得最大利润？

> 本质是允许将任意一段长度 $k$ 的区间修改为最优操作，其余区间必须按照提供的策略执行，问最大收益。

### 解题思路

#### 1. 按照给定的strategy全部执行，作为“原始收益”

- 依次遍历 `prices` 和 `strategy`，原始收益为 $\sum_{i} prices[i] \times strategy[i]$。

#### 2. 前缀和预处理

- 计算前缀和数组 `pre`，使得区间 $[l, r]$ 内按 strategy 执行的总收益为 $pre[r+1] - pre[l]$。方便后续滑窗计算。

#### 3. 枚举长度为 $k$ 的区间，计算“贪心切换”的最大提升

- 枚举每个区间 $[i-k+1,\,i]$（右端点为 $i$，区间长度是 $k$）。
    - 替换后该区间收益是多少？（本题样例代码中用 $s$ 表示）
    - 用贪心法——对于该区间，尽可能在低点买入、高点卖出（但本题默认只关注收益最大即可）。
    - 实际中样例代码的 $s$ 表示用某种策略（比如全买入或全卖出等）在该区间获得的最大收益。
    - 与原本区间收益 $pre[i+1] - pre[i-k+1]$ 做对比，取较大值，累加后全局做最大化。

### 复杂度分析

- 时间复杂度：$O(n)$，主要为一次前缀和和一次滑动窗口遍历。
- 空间复杂度：$O(n)$，主要为前缀和数组。

**Python3**

```python
class Solution:
    def maxProfit(self, prices: List[int], strategy: List[int], k: int) -> int:
        n = len(prices)
        ans = s = 0
        pre = [0] * (n + 2)

        for i in range(n):
            pre[i + 1] = pre[i] + prices[i] * strategy[i]
            ans += prices[i] * strategy[i]
        pre[n + 1] = pre[n]
        tmp = ans

        for i in range(len(prices)):
            if k // 2 <= i:  # 滑动窗口的左边界
                s += prices[i]
            
            if i - k + 1 > 0:
                s -= prices[i - k // 2]

            if i >= k - 1 and s > pre[i + 1] - pre[i - k + 1]:
                ans = max(ans, tmp + s - (pre[i + 1] - pre[i - k + 1]))
        return ans
```