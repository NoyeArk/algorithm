# [3714. 最长的平衡子串 II](https://leetcode.cn/problems/longest-balanced-substring-ii/description/)

> **日期**：2026-02-19  
> **知识点**：前缀和、哈希表

## 1. 题目描述

给定一个字符串 `s`，请找出其中最长的**平衡子串**的长度。

**平衡子串**的定义：子串中所有出现过的字符，出现次数都相同。

例如：
- `"ab"`、`"aabb"`、`"abc"`、`"aabbcc"` 都是平衡的（每种字符出现次数相等）；
- `"aab"` 不是平衡的（a 出现 2 次，b 出现 1 次）。

**约束：**
- `1 <= s.length <= 10^5`（或题目给定）
- `s` 仅由小写英文字母组成（最多 26 种字符，本题可只考虑 a/b/c 三类）

**示例 1：**

```
输入：s = "abc"
输出：3
解释：整个串 "abc" 中 a、b、c 各出现 1 次，是平衡的，长度为 3。
```

**示例 2：**

```
输入：s = "aabb"
输出：4
解释："aabb" 中 a 和 b 各出现 2 次，是平衡的，长度为 4。
```

**示例 3：**

```
输入：s = "aaa"
输出：1
解释：仅一种字符时，可视为出现次数相同，最长平衡子串长度为 1。
```

## 2. 分类讨论（单字符 / 两字符 / 三字符）+ 前缀和与哈希表

平衡子串只可能由**一种、两种或三种**字符组成，分三类处理：

- **情况一（单字符）**：最长连续相同字符段，扫一遍用 `last` 维护当前段长，更新最大值。
- **情况二（两种字符 x, y）**：只含 x、y 的极长段内，将 x 视为 +1、y 视为 -1 做前缀差 `diff`；相同 `diff` 的两位置之间即平衡子串。用哈希表记录每个 `diff` 首次出现位置，枚举右端点更新答案。对 (a,b)、(b,c)、(a,c) 各跑一遍取最大。
- **情况三（三种字符 a,b,c）**：用 `pre[0],pre[1],pre[2]` 表示 a,b,c 的前缀个数，平衡等价于 `pre[i]-pre[j]` 在两维上都相等。以 `(pre[0]-pre[1], pre[1]-pre[2])` 为 key 存首次下标，枚举右端点更新答案。

复杂度分析：

- **时间复杂度**：$O(n)$，单字符与三字符各一遍扫描，两字符对三组 (x,y) 各 $O(n)$。
- **空间复杂度**：$O(n)$ 或 $O(1)$（哈希表 key 数量有界）。

**Python3**

```python
class Solution:
    def longestBalanced(self, s: str) -> int:
        n = len(s)
        ans = 0

        # 情况一
        last = 0
        for i in range(n):
            last = last + 1 if i > 0 and s[i] == s[i - 1] else 1
            ans = max(ans, last)
        
        # 情况二
        def work(x, y):
            ans = 0
            i = 0
            while i < n:
                if s[i] not in (x, y):
                    i += 1
                    continue
                pos = {0: i - 1}
                diff = 0
                while i < n and s[i] in (x, y):
                    diff += 1 if s[i] == x else -1
                    if diff in pos:
                        ans = max(ans, i - pos[diff])
                    else:
                        pos[diff] = i
                    i += 1
                i += 1
            return ans
        
        ans = max(ans, work('a', 'b'), work('b', 'c'), work('a', 'c'))

        # 情况三
        pre = [0, 0, 0]
        pos = {(0, 0): -1}
        for i, c in enumerate(s):
            pre[ord(c) - 97] += 1
            key = (pre[0] - pre[1], pre[1] - pre[2])
            if key in pos:
                ans = max(ans, i - pos[key])
            else:
                pos[key] = i
        return ans
```