# [1292. 元素和小于等于阈值的正方形的最大边长](https://leetcode.cn/problems/largest-square-submatrix-with-sum-less-than-or-equal-to-threshold/description/)

> **日期**：2026-01-19  
> **所用时间**：10min  
> **知识点**：前缀和、二分答案

## 1. 题目描述

给你一个大小为 `m x n` 的矩阵 `mat` 和一个整数阈值 `threshold`。

请你返回元素总和小于或等于 `threshold` 的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。
 

**示例 1：**

> **输入：** `mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4`  
> **输出：** `2`  
> **解释：** 总和小于或等于 `4` 的正方形的最大边长为 `2`。

**示例 2：**

> **输入：** `mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1`  
> **输出：** `0`  
> **解释：** 没有总和小小于或等于 `1` 的正方形区域。

**提示：**

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 300`
- `0 <= mat[i][j] <= 104`
- `0 <= threshold <= 105` 

## 2. 前缀和 + 二分答案

### 题解

这道题目要求，在一个矩阵中找到**总和不超过 threshold 的最大正方形子矩阵的边长**。

#### 1. 经典思路：二维前缀和 + 二分

- **二维前缀和（Integral Image）** 能高效计算任意子矩阵内所有数的和，时间复杂度为 $O(1)$，预处理复杂度 $O(nm)$（$n$、$m$ 分别为行和列数）。
    - 公式为：`pre[i][j]` 表示从 $(0,0)$ 到 $(i-1,j-1)$ 的元素和。
    - 对于坐标 $(i_1,j_1)$ 到 $(i_2,j_2)$ 的矩形和：  
      `pre[i2+1][j2+1] - pre[i2+1][j1] - pre[i1][j2+1] + pre[i1][j1]`

- **二分答案：**
    - 最小边长 $l=0$，最大为 $r=\min(m, n)$。
    - 检查对于边长 $mid$ 是否存在某个正方形，其和 $\leq threshold$。
    - 若存在，增大 $l$，否则缩小 $r$。

#### 2. 算法流程

1. **计算二维前缀和矩阵**  
   预处理 $O(nm)$

2. **二分检验：**
    - 枚举所有大小为 $mid \times mid$ 的正方形左上角 $(r1, c1)$
    - 通过前缀和求正方形区域内和
    - 若发现有某个和 $\leq threshold$ 就返回 `True`

3. **答案更新方式：**
    - 如果当前边长可行，尝试加大边长
    - 否则减小，最终返回最大的可行边长

#### 3. 时间复杂度

- 预处理前缀和 $O(nm)$
- 二分次数 $O(\log(\min(n, m)))$，每次 $O(nm)$，总共 $O(nm \log(\min(n, m)))$，可通过本题数据范围。

#### 4. 代码及说明

- `pre` 是 $n+1 \times m+1$ 的前缀和矩阵，方便边界处理。
- `check(mid)` 检查是否存在边长为 `mid` 的正方形，其和 $\leq threshold$
- 最终答案是 $r$，表示最大的可行边长。

这种“二分答案 + 前缀和”方式是本类区域和上界限制的矩阵题的经典模板。

**Python3**

```python
class Solution:
    def maxSideLength(self, mat: List[List[int]], threshold: int) -> int:
        n, m = len(mat), len(mat[0])
        pre = [[0] * (m + 1) for _ in range(n + 1)]

        for i, row in enumerate(mat):
            for j, x in enumerate(row):
                pre[i + 1][j + 1] = pre[i + 1][j] + pre[i][j + 1] - pre[i][j] + x
        
        def check(mid):
            for r1 in range(n - mid + 1):
                for c1 in range(m - mid + 1):
                    r2, c2 = r1 + mid - 1, c1 + mid - 1
                    if pre[r2 + 1][c2 + 1] - pre[r2 + 1][c1] - pre[r1][c2 + 1] + pre[r1][c1] <= threshold:
                        return True
            return False
        
        l, r = 0, min(n, m)
        while l < r:
            mid = l + r + 1 >> 1
            if check(mid):
                l = mid
            else:
                r = mid - 1
        return r
```