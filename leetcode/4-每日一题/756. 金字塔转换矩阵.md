# [756. 金字塔转换矩阵](https://leetcode.cn/problems/pyramid-transition-matrix/description/)

> **日期**：2025-12-29  
> **所用时间**：23min  
> **知识点**：记忆化搜索

## 1. 记忆化搜索

每一层的字符串可以视为当前“状态”，每次从当前层（字符串），基于 `allowed` 中的三元组，尝试构造所有可能的上一层。

问题转换为：是否存在一条“路径”，从给定 `bottom` 经递归层层构造，能到达长度为 1 的字符串。

把 allowed 表达的规则变成哈希表 map，将所有能由同一组相邻字符生成的上方字符收集起来。

例如 "XYD" 意味着 'X'+'Y' 可以放 'D'，于是 map["XY"] = ['D']

递归函数 check(bottom) 含义为：给定底层 bottom，能否最终堆成金字塔（到长度为 1）。

对于每两个相邻的字符，查询 map，看能“向上”放哪些字符，由于相邻一对可能对应多种可能下一层，每组情况下递归 check 并尝试所有可能性，如果某一层 bottom 没有任何可能向上的方案，立即返回 false。

利用记忆化（cache）避免重复计算同一层的结果，由于每一步递归都会生成所有可能的新一层，几乎是指数型增长，但有缓存剪枝，实际运行较快。具体复杂度依赖于 allowed 的分布和 bottom 的长度。

复杂度分析：

- 时间复杂度: $O(n \times k^n)$
- 空间复杂度: $O(n \times k^n)$

**Python3**

```python
class Solution:
    def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
        mp = defaultdict(list)
        for s in allowed:
            mp[s[:2]].append(s[-1])

        @cache
        def check(bottom):
            if len(bottom) == 1:
                return True
            
            bottoms = [""]
            for a, b in pairwise(bottom):
                if a + b not in mp:
                    return False
                t = []
                for c in mp[a + b]:
                    for s in bottoms:
                        t.append(s + c)
                bottoms = t
            
            return any(check(bottom) for bottom in bottoms)
        
        return check(bottom)
```