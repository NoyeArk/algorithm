# [696. 计数二进制子串](https://leetcode.cn/problems/count-binary-substrings/description/)

> **日期**：2026-02-19
> **所用时间**：11min
> **知识点**：分组计数 / 滑动窗口

## 1. 题目描述

给定一个二进制字符串 `s`，统计并返回具有相同数量的 `0` 和 `1` 的非空子字符串的数量，并且这些子字符串中的所有 `0` 和所有 `1` 都是连续的。

重复出现的子串要统计它们出现的次数。

**示例 1：**

```
输入：s = "00110011"
输出：6
解释：6 个子串满足具有相同数量的连续 1 和 0：
- "0011"，"01"，"1100"，"10"，"0011" 和 "01"。
注意，一些重复出现的子串（不同位置）要统计它们出现的次数。
另外，"00110011" 不是有效的子串，因为所有的 0（和 1）没有组合在一起。
```

**示例 2：**

```
输入：s = "10101"
输出：4
解释：有 4 个子串："10"，"01"，"10"，"01"，具有相同数量的连续 1 和 0。
```

**提示：**

- `1 <= s.length <= 10^5`
- `s[i]` 为 `'0'` 或 `'1'`

## 2. 分组计数

将字符串按连续相同字符分组，例如 `"00110011"` 可分为 `[2, 2, 2, 2]`（2 个 0、2 个 1、2 个 0、2 个 1）。相邻两组之间能形成的满足条件的子串数量为 `min(pre, cur)`。使用 `pairwise` 遍历相邻字符，`pre` 记录上一段长度，`cur` 记录当前段长度，遇到字符变化时累加 `min(pre, cur)` 并更新 `pre, cur`。

- 时间复杂度: $O(n)$
- 空间复杂度: $O(1)$

**Python3**

```python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        ans, pre, cur = 0, 0, 1
        for a, b in pairwise(s):
            if a == b:
                cur += 1
            else:
                ans += min(pre, cur)
                pre, cur = cur, 1
        return ans + min(pre, cur)
```