# [762. 二进制表示中质数个计算置位](https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation/description/)

> **日期**：2026-02-21  
> **所用时间**：4min  
> **知识点**：位运算、质数判定

## 1. 题目描述

给你两个整数 `left` 和 `right`，在闭区间 `[left, right]` 内，统计满足「**二进制表示中 1 的个数是质数**」的整数个数。

**计算置位**即二进制中 `1` 的个数。例如 `21` 的二进制为 `10101`，有 3 个计算置位。

**示例 1：**

```
输入：left = 6, right = 10
输出：4
解释：6→110(2 个 1，2 是质数)、7→111(3，质数)、8→1000(1，非质数)、9→1001(2，质数)、10→1010(2，质数)，共 4 个。
```

**示例 2：**

```
输入：left = 10, right = 15
输出：5
解释：10(2)、11(3)、12(2)、13(3)、14(3)、15(4 非质数)，共 5 个。
```

**提示：**

- `1 <= left <= right <= 10^6`
- `right - left <= 10^4`

## 2. 遍历 + 位运算 + 质数判定

对 `[left, right]` 中每个数 `x`，用 `x.bit_count()`（或 `bin(x).count('1')`）得到二进制中 1 的个数；再判断该个数是否为质数（如用试除法或打表，因位数最多约 20，质数只有 2,3,5,7,11,13,17,19）。满足则计数 +1。

复杂度分析：
- **时间复杂度**：$O((\textit{right}-\textit{left}+1) \cdot \sqrt{20})$，质数判定上界很小。
- **空间复杂度**：$O(1)$（或 $O(1)$ 打表）。

**Python3**

```python
class Solution:
    def countPrimeSetBits(self, left: int, right: int) -> int:
        @cache
        def is_prime(x):
            if x < 2:
                return False
            i = 2
            while i * i <= x:
                if x % i == 0:
                    return False
                i += 1
            return True

        return sum(int(is_prime(x.bit_count())) for x in range(left, right + 1))
```