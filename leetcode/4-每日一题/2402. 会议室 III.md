# [2402. 会议室 III](https://leetcode.cn/problems/meeting-rooms-iii/description/)

> **日期:** 2024-12-27
> **所用时间:** 17min
> **知识点:** 堆、模拟

## 1. 堆模拟

本题不能暴力模拟每个会议室的全程状态，否则会超时。考虑以下高效做法：

所有会议按 `start` 升序排序，确保按照时间线依次处理。

使用小顶堆 `free` 维护当前所有空闲会议室的编号（保证分配最小编号房间）。

使用小顶堆 `busy` 维护所有正在被占用的会议室，堆顶是最早结束的会议，元素为 `(结束时间, 会议室编号)`。

复杂度分析：

- 时间复杂度：$O(m \log n)$，$m$ 为会议数量，$n$ 为会议室数量。因为每场会议最多操作一次堆，堆的大小不超过 $n$。
- 空间复杂度：$O(n)$，主要是堆和计数数组。

**Python3**

```python
class Solution:
    def mostBooked(self, n: int, meetings: List[List[int]]) -> int:
        meetings.sort()

        free = list(range(n))
        busy = []
        cnts = [0] * n

        for st, ed in meetings:
            while busy and busy[0][0] <= st:
                heappush(free, heappop(busy)[1])
            
            if free:
                i = heappop(free)
            else:
                end, i = heappop(busy)
                ed = end + ed - st
            
            heappush(busy, (ed, i))
            cnts[i] += 1

        return cnts.index(max(cnts))
```