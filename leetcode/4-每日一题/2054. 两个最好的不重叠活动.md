# [2054. 两个最好的不重叠活动](https://leetcode.cn/problems/two-best-non-overlapping-events/description/)

> **日期**：2025-12-23
> **所用时间**：25min
> **知识点**：排序、单调栈、二分

## 1. 详细题解

### 题目理解

给定一些活动 `events`，每个活动由 `[start, end, value]` 表示其开始时间、结束时间和价值。你只能选择 **两个互不重叠** 的活动，使得它们的价值和最大。活动时间是闭区间 `[start, end]`，即如果一个的结束时间是 3，另一个的起始时间是 3，则二者重叠。

### 思路分析

1. **排序与前缀最大值**
    - 先按结束时间排序所有活动。这样每次选择了第二个活动后，可以用二分查找（bisect）快速找到**所有在当前活动开始前已结束的活动的最大价值**。
    - 用一个栈 `stk`，每一项为 (end_time, max_value)：
      - `stk[i]` 代表所有结束时间 $\leq stk[i][0]$ 的活动中，`value` 的最大值为 `stk[i][1]`。
      - 初始入栈 `(0, 0)`，表示还没有选择过活动，最大和为 0。

2. **枚举第二个活动**
    - 依次遍历排序后的 `events`，对于每个当前活动 `[st, ed, val]`，想象它作为第二个活动加入。
    - 二分 $O(\log n)$ 找到最后一个 `end_time < st` 的活动获得最大值 `max_value`（即两活动不重叠），此时总体价值和为 `val + max_value`。
    - 用 `ans` 更新全局最大值。
    - 为了支持查找，将当前的 `(ed, max(本次val, stk[-1][1]))` 入栈，持续维护截止到每个结束时间的最大 value。

3. **复杂度分析**
    - 排序 $O(n \log n)$。
    - 遍历加二分 $O(n \log n)$。
    - 总复杂度 $O(n \log n)$，空间 $O(n)$。

**Python3**

```python
class Solution:
    def maxTwoEvents(self, events: List[List[int]]) -> int:
        events.sort(key=lambda e: e[1])

        stk = [(0, 0)]
        ans = 0
        for st, ed, val in events:
            i = bisect_left(stk, (st,)) - 1
            ans = max(ans, stk[i][1] + val)
            if val > stk[-1][1]:
                stk.append((ed, val))
        return ans
```