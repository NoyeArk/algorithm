# [3010. 将数组分成最小总代价的子数组 I](https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/description/)

> **日期**：2026-01-31  
> **所用时间**：5min  
> **知识点**：贪心

## 1. 题目描述

给你一个长度为 n 的整数数组 nums。

将数组分成 3 个**非空**连续子数组，从左到右分别记为子数组 1、2、3。每个子数组的**代价**为该子数组中的第一个元素。

请你返回将数组分成 3 个子数组的**最小总代价**。

示例 1：

输入：nums = [1,2,3,12]

输出：6

解释：最优划分方案为 [1]、[2]、[3,12]，代价分别为 1、2、3，总代价为 1 + 2 + 3 = 6。

示例 2：

输入：nums = [5,4,3]

输出：12

解释：唯一划分方案为 [5]、[4]、[3]，总代价为 5 + 4 + 3 = 12。

## 2. 解题算法

题意要求把数组分成恰好 3 段连续子数组，每段代价为该子数组的第一个元素，求最小总代价。

由于第一段一定从下标 0 开始，第一段的代价一定是 nums[0]。要让总代价最小，只需让第二段、第三段的「开头元素」尽可能小，即从 nums[1:] 中选出两个最小的数，分别作为第二段和第三段的第一个元素即可。

因此算法为：取 nums[0]，再加上 nums[1:] 中两个最小值的和。实现时可将 nums[1:] 排序后取前两个再求和，或线性扫描维护最小和次小。

复杂度分析：

- 时间复杂度：O(n)（线性扫描求两最小）或 O(n log n)（排序取前两个）。
- 空间复杂度：O(1)（扫两遍或维护两个变量）或 O(n)（若对 nums[1:] 排序）。

**Python3**

```python
class Solution:
    def minimumCost(self, nums: List[int]) -> int:
        return nums[0] + sum(sorted(nums[1:])[:2])
```
