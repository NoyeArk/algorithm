# [744. 寻找比目标字母大的最小字母](https://leetcode.cn/problems/find-smallest-letter-greater-than-target/description/)

> **日期**：2026-01-31
> **所用时间**：5min

## 1. 题目描述

给你一个字符数组 letters，该数组按非递减顺序排序，以及一个字符 target。letters 里至少有两个不同的字符。

返回 letters 中大于 target 的最小的字符。如果不存在这样的字符，则返回 letters 的第一个字符。

示例 1：

输入: letters = ['c', 'f', 'j']，target = 'a'

输出: 'c'

解释：letters 中字典上比 'a' 大的最小字符是 'c'。

## 2. 二分

本题是一道典型的二分查找应用题。

#### 思路分析

由于 `letters` 是**有序数组**，目标是寻找**第一个比 target 大的字母**，当没有比 target 大的字母时应该**返回第一个字母**。  
二分查找最适合解决“有序数组中的第一个满足某性质的元素”这类问题。

具体做法：

1. 设定左右指针 `l=0, r=n-1`，不断缩小区间。
2. 二分中，如果 `letters[mid] > target`，说明 mid 及其左侧都有可能是答案，r=mid。
3. 如果 `letters[mid] <= target`，左端点右移，l=mid+1。
4. 结束条件后，判断 `letters[r]` 是否大于 target，如果不是（说明 target 至少与所有 letters 中元素相等或更大），返回 letters[0]，即首元素。

#### 例子

比如 letters = ['c', 'f', 'j']，target = 'j'，所有字母都不大于 target，此时应返回 'c'。

#### 复杂度

- 时间复杂度 O(log n)
- 空间复杂度 O(1)

**Python3**

```python
class Solution:
    def nextGreatestLetter(self, letters: List[str], target: str) -> str:
        n = len(letters)
        l, r = 0, n - 1

        while l < r:
            mid = l + r >> 1
            if letters[mid] > target:
                r = mid
            else:
                l = mid + 1
        return letters[r] if letters[r] > target else letters[0]
```