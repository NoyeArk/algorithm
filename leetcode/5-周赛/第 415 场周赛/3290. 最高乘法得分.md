# 3290. 最高乘法得分

> **日期**：2024-09-15  
> **所用时间**：12min  
> **知识点**：动态规划、记忆化搜索

## 1. 题目描述

给定两个整数数组 `a` 和 `b`，长度分别为 `n` 和 `m`（保证 $m \ge n$）。

你需要从 `b` 中**按顺序**选出恰好 `n` 个下标 $j_0 < j_1 < \cdots < j_{n-1}$，并将 `a[i]` 与 `b[j_i]` 一一配对。**乘法得分**定义为所有配对乘积之和：

$$
\sum_{i=0}^{n-1} a[i] \times b[j_i]
$$

求可能得到的**最高乘法得分**。

**示例 1：**

- **输入**：a = [2, 1, 3], b = [1, 2, 3, 4]
- **输出**：20
- **解释**：从 b 中按顺序选 3 个下标与 a 配对，使乘积和最大即可得到 20。

**示例 2：**

- **输入**：a = [1, 2], b = [1, 2, 3]
- **输出**：8
- **解释**：选 b 的下标 [1, 2]，得分为 1*2 + 2*3 = 8。

**提示：**

- $1 \le n \le m$
- $1 \le n, m \le 500$
- 数组元素为整数（可能为负，以题目约束为准）。

## 2 记忆化搜索

状态：$dfs(i, j)$ 表示在数组 `a` 的前 $i+1$ 个元素与数组 `b` 的前 $j+1$ 个元素中，已按顺序配对完 $a[0..i]$ 与某 $j+1$ 个位置中的 $i+1$ 个来自 `b` 的元素时，能得到的最大得分（即从 `b[0..j]` 里选恰好 $i+1$ 个做配对）。

- **当 $i < 0$**：无元素可配，返回 $0$。
- **当 $i = j$**：`a[0..i]` 与 `b[0..j]` 长度均为 $i+1$，必须一一配对，故 $dfs(i, j) = dfs(i-1, j-1) + a[i] \times b[j]$。
- **当 $i \neq j$**：要么将 $a[i]$ 与 $b[j]$ 配对，得 $dfs(i-1, j-1) + a[i] \times b[j]$；要么不选 $b[j]$，得 $dfs(i, j-1)$。取两者最大值。

复杂度分析：

- 时间复杂度：$O(nm)$
- 空间复杂度：$O(nm)$

**Python3**

```python
class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        @cache
        def dfs(i, j):
            if i < 0:
                return 0
            if i == j:
                return dfs(i - 1, j - 1) + a[i] * b[j]
            return max(dfs(i - 1, j - 1) + a[i] * b[j], dfs(i, j - 1))
        return dfs(len(a) - 1, len(b) - 1)
```

## 3 递推（DP 表）

将上述记忆化搜索改为递推：$f[i][j]$ 表示考虑 `a` 的前 $i$ 个元素与 `b` 的前 $j$ 个元素时能得到的最大得分（即从 `b[0..j-1]` 中选恰好 $i$ 个与 `a[0..i-1]` 配对的最大和）。

- 当 $i = j$：必须配对 $a[i-1]$ 与 $b[j-1]$，故 $f[i][j] = f[i-1][j-1] + a[i-1] \times b[j-1]$。
- 当 $i \neq j$：要么配对 $a[i-1]$ 与 $b[j-1]$，得 $f[i-1][j-1] + a[i-1] \times b[j-1]$；要么不选 $b[j-1]$，得 $f[i][j-1]$。取最大值。

按 $i$、$j$ 递增递推，答案为 $f[n][m]$。

复杂度分析：

- 时间复杂度：$O(nm)$
- 空间复杂度：$O(nm)$

**Python3**

```python
class Solution:
    def maxScore(self, a: List[int], b: List[int]) -> int:
        n, m = len(a), len(b)
        f = [[0] * (m + 1) for _ in range(n + 1)]

        for i, x in enumerate(a):
            for j, y in enumerate(b):
                if i == j:
                    f[i + 1][j + 1] = f[i][j] + x * y
                else:
                    f[i + 1][j + 1] = max(f[i][j] + x * y, f[i + 1][j])
        return f[n][m]
```