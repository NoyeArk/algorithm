# [3850. 统计结果等于 K 的序列数目](https://leetcode.cn/problems/count-sequences-to-k/)

> **日期**：2026-02-22  
> **所用时间**：30min  
> **知识点**：记忆化搜索、DFS

## 1. 题目描述

给定一个整数数组 `nums` 和一个整数 `k`。对每个下标 `i`，你可以从三种操作中任选其一：**不选**该数、将当前结果**乘以** `nums[i]`、或将当前结果**除以** `nums[i]`（整除或浮点除依题意）。每个位置至多使用一次。

求有多少种**操作序列**，使得按顺序执行后得到的**结果等于** `k`。

（若题意为「从右到左」或「表达式结果为 k」等变种，逻辑等价：用当前值 `k` 倒推，DFS 时枚举不选 / 乘 / 除三种后继状态，边界为下标越界时检查当前值是否为 1 或 k。）

**示例 1：**

```
输入：nums = [2, 3, 4], k = 6
输出：（依题意计算）
解释：例如 2 * 3 = 6、或 4 不选且 2*3=6 等，统计所有使结果等于 k 的序列数。
```

**提示：**

- `1 <= nums.length <= 30`
- `1 <= nums[i], k <= 10^9`（或题目给定范围）

## 2. 记忆化 DFS

从右到左（或从左到右）枚举下标 `i`，当前「目标值」为 `k`：若已处理完所有元素（`i < 0`），则若当前目标为 1 则贡献 1 种方案，否则 0；否则三种分支：不选 `nums[i]`（目标仍为 `k`）、选乘（目标变为 `k / nums[i]`）、选除（目标变为 `k * nums[i]`）。

用 `@cache` 记忆化 `(i, k)` 的答案，避免重复计算。注意浮点比较时用 `abs(1 - k) < 1e-5` 等判等。

复杂度分析：

- 时间复杂度：$O(n \cdot S)$，其中 $S$ 为状态数（与 k 的因子或离散化后的状态数相关）。
- 空间复杂度：$O(n \cdot S)$，为记忆化缓存。

**Python3**

```python
class Solution:
    def countSequences(self, nums: List[int], k: int) -> int:
        @cache
        def dfs(i, k):
            if i < 0:
                return int(abs(1 - k) < 1e-5)
            return dfs(i - 1, k) + dfs(i - 1, k * nums[i]) + dfs(i - 1, k / nums[i])
        return dfs(len(nums) - 1, k)
```