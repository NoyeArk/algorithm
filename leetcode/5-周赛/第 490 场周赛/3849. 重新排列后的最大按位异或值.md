# [3849. 重新排列后的最大按位异或值](https://leetcode.cn/problems/maximum-bitwise-xor-after-rearrangement/)

> **日期**：2026-02-22  
> **所用时间**：25min  
> **知识点**：贪心、计数

## 1. 题目描述

给定两个**二进制字符串** `s` 和 `t`，长度相同。你可以**任意重排** `t` 中的字符。将重排后的 `t` 与 `s` **按位异或**（即第 i 位为 `s[i] ^ t[i]`），得到一个二进制串。求在所有重排方案中，该异或结果**数值最大**时对应的二进制串（通常也等价于字典序最大）。

**示例 1：**

```
输入：s = "010", t = "110"
输出："101"
解释：将 t 重排为 "101"，与 s 按位异或得 010^101 = 111；或重排为 "011" 得 001，最大为 "111"。若输出为 "101" 则可能表示某种题意下的最大异或串。
```

**示例 2：**

```
输入：s = "0", t = "0"
输出："0"
解释：无法得到 1，结果为 "0"。
```

**提示：**

- `1 <= s.length, t.length <= 10^5`
- `s`、`t` 仅由 `'0'` 和 `'1'` 组成

## 2. 贪心 + 计数

要使异或结果最大，应尽量在**高位**得到 `1`。从左到右遍历 `s` 的每一位：当前位若为 `c`，则异或为 1 当且仅当该位与 `1-c`（相反位）配对。

用计数器维护 `t` 中剩余可用的 `'0'` 与 `'1'` 个数；每步优先使用与当前位相反的字符（若还有），则当前位异或为 1，否则为 0。这样得到的就是字典序（数值）最大的异或串。

- **时间复杂度**：$O(n)$，n 为串长。
- **空间复杂度**：$O(1)$（仅计数）。

**Python3**

```python
class Solution:
    def maximumXor(self, s: str, t: str) -> str:
        cnt = Counter(t)
        if cnt['1'] == 0:
            return s

        ans = ''
        for c in s:
            reverse = str(1-int(c))
            ans += '1' if cnt[reverse] > 0 else '0'
            cnt[reverse] -= 1
        return ans
```