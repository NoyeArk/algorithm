# [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/description/)

> **日期**：2024-08-27
> **所用时间**：14min

## 1. 动态规划

### 1.1 状态表示

$f[i][j][k]$ 表示在选择前 $i$ 个字符串时，最多含有 $j$ 个0和 $k$ 个1的最大物品个数。

### 1.2 状态计算

对于每个状态有选和不选两种操作：

- 如果不选第 $i$ 个字符串：

1. 二进制字符串数组中的每个字符串对应背包中每个物品的体积
2. 最多含有$m$个0和$n$个1对应背包的大小限制

求满足题意的情况下，背包中最多能够装多少个物品。

状态表示：$f[i][j][k]$表示在选择第$i$物品时背包中0的个数不超过$j$，1的个数不超过$k$的最大物品个数

状态计算：

- 不选第$i$个物品：

$$
    f[i][j][k] = f[i - 1][j][k]
$$

- 选第$i$个物品

$$
    f[i][j][k] = f[i - 1][j - strs[i]中0的个数][k - strs[i]中1的个数] + 1
$$

- 时间复杂度：$O(len(strs)\times n\times m)$
- 空间复杂度：$O(len(strs)\times n\times m)$

```C++
class Solution {
public:
    int f[610][110][110];

    int get_zero(string s)
    {
        int res = 0;
        for (auto c : s) 
            if (c == '0') res ++;
        return res;
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        int ans = 0;
        for (int i = 1; i <= strs.size(); i ++)
            for (int j = 0; j <= m; j ++)
                for (int k = 0; k <= n; k ++)
                {
                    f[i][j][k] = f[i - 1][j][k];
                    int zeros = get_zero(strs[i - 1]), ones = strs[i - 1].size() - zeros;
                    if (zeros <= j && ones <= k) 
                        f[i][j][k] = max(f[i][j][k], f[i - 1][j - zeros][k - ones] + 1);
                    ans = max(ans, f[i][j][k]);
                }
        return ans;
    }
};
```

### 2.时间空间优化

通过状态转移方程可以发现，计算当前状态时只用到了上一层的状态，因此可以使用滚动数组来进行空间优化。

将第一维删除，同时要把对$j$和$k$的循环改成从大到小，因此每次计算的时候是利用低地址的数据进行更新，因此要从高地址向低地址开始计算。

同时将判断条件$zeros \leq j $和$ ones \leq k$可以直接写在for循环的判断条件中，避免不必要的循环。

- 时间复杂度：$O(len(strs)\times n\times m)$
- 空间复杂度：$O(n\times m)$

```C++
class Solution {
public:
    int f[110][110];

    int get_zero(string s)
    {
        int res = 0;
        for (auto c : s) 
            if (c == '0') res ++;
        return res;
    }

    int findMaxForm(vector<string>& strs, int m, int n) {
        int ans = 0;
        for (int i = 1; i <= strs.size(); i ++)
        {
            int zeros = get_zero(strs[i - 1]), ones = strs[i - 1].size() - zeros;
            for (int j = m; j >= zeros; j --)
                for (int k = n; k >= ones; k --)
                    f[j][k] = max(f[j][k], f[j - zeros][k - ones] + 1),
                    ans = max(ans, f[j][k]);
        }
        return ans;
    }
};
```

## 3. 记忆化搜索

我们可以用**记忆化搜索（递归+缓存）**来解决。

- **状态定义**：`dfs(i, m, n)` 表示在前 `i` 个字符串中，剩余 `m` 个 0 和 `n` 个 1 的情况下，最多能选多少个字符串。
- **选择**：对于第 `i` 个字符串，有两种选择：
    1. **不选**：直接跳到 `dfs(i-1, m, n)`
    2. **选**：如果剩余的 0 和 1 足够，则可以选，转移到 `dfs(i-1, m-cnt0, n-cnt1) + 1`，其中 `cnt0` 和 `cnt1` 分别是第 `i` 个字符串中 0 和 1 的数量。
- **边界条件**：当 `i < 0` 时，说明没有字符串可选，返回 0。
- **记忆化**：用 `@cache`（或 `lru_cache`）装饰器缓存递归结果，避免重复计算。

**Python3**

```Python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        @cache
        def dfs(i, m, n):
            if i < 0:
                return 0
            res = dfs(i - 1, m, n)
            cnt0, cnt1 = strs[i].count('0'), strs[i].count('1')
            if m >= cnt0 and n >= cnt1:
                res = max(res, dfs(i - 1, m - cnt0, n - cnt1) + 1)
            return res
        return dfs(len(strs) - 1, m, n)
```