# [1027. 最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/description/)

> **日期:** 2024-08-04、2026-01-07  
> **所用时间:** 24min
> **知识点:** 动态规划

## 1. 题目要求

给定一个整数数组 `nums`，返回数组中最长等差子序列的长度。

**示例 1:**

```
输入: nums = [3, 6, 9, 12]
输出: 4
```

解释：最长的等差子序列是 [3, 6, 9, 12]。

**示例 2:**

```
输入: nums = [9,4,7,2,10]
输出: 3
```

解释：最长的等差子序列是 [4, 7, 10]。

**提示:**

- `2 <= nums.length <= 1000`
- `0 <= nums[i] <= 500`

## 2. 动态规划

状态表示：$f[i][d]$ 表示以第 $i$ 个元素结尾公差为 $d$ 的等差子序列的长度

状态计算：

$$	f[i][d] = f[j][d] + 1 $$

复杂度分析：

- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(500n)$

**Python3**

```python
class Solution:
    def longestArithSeqLength(self, nums: List[int]) -> int:
        ans = 0
        n = len(nums)
        f = [[1] * 1001 for _ in range(n)]

        for i in range(n):
            for j in range(i):
                diff = nums[i] - nums[j] + 500
                f[i][diff] = f[j][diff] + 1
                ans = max(ans, f[i][diff])
        return ans
```

**C++**

```C++
class Solution {
public:
    int f[1010][1010];

    int longestArithSeqLength(vector<int>& nums) {
        int n = nums.size(), ans = 0;
        
        for (int i = 1; i <= n; i ++)
            for (int j = 1; j < i; j ++)
            {
                int diff = nums[i - 1] - nums[j - 1] + 500;
                f[i][diff] = f[j][diff] + 1;
                ans = max(ans, f[i][diff]);
            }

        return ans + 1;
    }
};
```