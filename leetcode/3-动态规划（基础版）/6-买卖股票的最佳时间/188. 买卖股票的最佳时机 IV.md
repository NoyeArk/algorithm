# [188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/description)

> **日期**：2024-09-22、2026-02-28  
> **所用时间**：11min  
> **知识点**：动态规划、记忆化搜索

## 1. 题目描述

给定一个整数 `k` 和一个整数数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。要求计算能够获得的最大利润。

**限制条件：**

- 最多可以完成 **k 笔** 交易（一笔交易指一次买入 + 一次卖出）。
- 不能同时参与多笔交易：再次买入前必须先卖出当前持有的股票。

**示例 1：**

- **输入**：k = 2, prices = [2,4,1]
- **输出**：2
- **解释**：第 1 天买入（价格 2），第 2 天卖出（价格 4），利润 2。

**示例 2：**

- **输入**：k = 2, prices = [3,2,6,5,0,3]
- **输出**：7
- **解释**：第 2 天买入（价格 2），第 3 天卖出（价格 6），利润 4；第 5 天买入（价格 0），第 6 天卖出（价格 3），利润 3。总利润 4 + 3 = 7。

**约束：**

- $1 \le k \le 100$
- $1 \le \text{prices.length} \le 1000$
- $0 \le \text{prices}[i] \le 1000$

---

## 2. 「动态规划 / 记忆化搜索」

**思路：**

与「123. 买卖股票的最佳时机 III」相同，将**最多 2 笔**推广为**最多 k 笔**。用**记忆化搜索**：`dfs(i, j, hold)` 表示考虑前 `i+1` 天、**剩余**可完成 `j` 笔交易、当前是否持有股票时的最大利润。

- 若 `j == 0`：不能再交易，返回 0。
- 若 `i < 0`：没有天数，持有则非法返回 $-\infty$，否则返回 0。
- 若当前持有：今天可**不卖**（`dfs(i-1, j, True)`）或**卖出**（`dfs(i-1, j-1, False) + prices[i]`，用掉 1 笔交易）。
- 若当前不持有：今天可**不买**（`dfs(i-1, j, False)`）或**买入**（`dfs(i-1, j, True) - prices[i]`）。

答案为 `dfs(len(prices)-1, k, False)`，即从最后一天、剩余 k 笔、不持有出发的最大利润。

**复杂度分析：**

- 时间复杂度：$O(n \cdot k)$（状态 $(i, j, \text{hold})$ 共 $O(n \cdot k \cdot 2)$，每状态 $O(1)$ 转移）
- 空间复杂度：$O(n \cdot k)$（递归栈与 cache）

**Python3**

```python
class Solution:
    def maxProfit(self, k: int, prices: List[int]) -> int:
        @cache
        def dfs(i, j, hold):
            if j == 0:
                return 0
            if i < 0:
                return -inf if hold else 0
            if hold:
                return max(dfs(i - 1, j, hold), dfs(i - 1, j - 1, False) - prices[i])
            return max(dfs(i - 1, j, hold), dfs(i - 1, j, True) + prices[i])
        return dfs(len(prices) - 1, k, False)
```