# [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description)

> **日期**：2024-09-21、2025-02-06  
> **所用时间**：13min  
> **知识点**：动态规划、记忆化搜索

## 1. 题目描述

给定一个整数数组 `prices`，其中 `prices[i]` 表示第 `i` 天的股票价格。要求计算能够获得的最大利润。

**限制条件：**

- 最多可以完成 **两笔** 交易（一笔交易指一次买入 + 一次卖出）。
- 不能同时参与多笔交易：再次买入前必须先卖出当前持有的股票。

**示例 1：**

- **输入**：prices = [3,3,5,0,0,3,1,4]
- **输出**：6
- **解释**：第 4 天买入（价格 0），第 6 天卖出（价格 3），利润 3；第 7 天买入（价格 1），第 8 天卖出（价格 4），利润 3。总利润 3 + 3 = 6。

**示例 2：**

- **输入**：prices = [1,2,3,4,5]
- **输出**：4
- **解释**：第 1 天买入（价格 1），第 5 天卖出（价格 5），利润 4。只需一笔交易即可达到最大利润。

**示例 3：**

- **输入**：prices = [7,6,4,3,1]
- **输出**：0
- **解释**：价格单调不升，无法通过交易获利，最大利润为 0。

**约束：**

- $1 \le \text{prices.length} \le 10^5$
- $0 \le \text{prices}[i] \le 10^5$

---

## 2. 「动态规划 / 记忆化搜索」

下面代码用**记忆化搜索**实现：`dfs(i, j, hold)` 表示考虑前 `i+1` 天、剩余可完成 `j` 笔交易、当前是否持有股票时的最大利润，答案为 `dfs(n-1, 2, False)`。

**复杂度分析：**

- 时间复杂度：$O(n)$（状态数 $O(n \times 2 \times 2)$，每状态 $O(1)$ 转移）
- 空间复杂度：$O(n)$（递归栈与 cache，若用二维 DP 数组则为 $O(5n)$）

**Python3**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        @cache
        def dfs(i, j, hold):
            if j == 0:
                return 0
            if i < 0:
                return -inf if hold else 0
            if hold:
                return max(dfs(i - 1, j, True), dfs(i - 1, j - 1, False) - prices[i])
            return max(dfs(i - 1, j, False), dfs(i - 1, j, True) + prices[i])
        return dfs(len(prices) - 1, 2, False)
```