# [322. 零钱兑换](https://leetcode.cn/problems/coin-change/description/)

> **日期**：2024-07-22、2026-02-06  
> **所用时间**：4min  
> **知识点**：动态规划、完全背包、记忆化搜索

## 1. 题目描述

给你一个整数数组 `coins`，表示不同面额的硬币；以及一个整数 `amount`，表示总金额。

计算并返回可以凑成总金额所需的**最少硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 `-1`。

每种硬币的数量是无限的。

**示例 1：**
```
输入：coins = [1, 2, 5], amount = 11
输出：3
解释：11 = 5 + 5 + 1
```

**示例 2：**
```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**
```
输入：coins = [1], amount = 0
输出：0
```

## 2. 解题算法

### 2.1 记忆化搜索

定义 `dfs(i, s)`：使用 `coins[0..i]` 凑成金额 `s` 所需的最少硬币数。

- 若 `i < 0`：无硬币可用，返回 `0`（当 `s == 0`）或 `inf`（否则）
- 若 `coins[i] > s`：当前硬币面额过大，只能不选，返回 `dfs(i - 1, s)`
- 否则：两种选择取最小值
  - 不选 `coins[i]`：`dfs(i - 1, s)`
  - 选 `coins[i]`：`1 + dfs(i, s - coins[i])`（完全背包，可重复选）

使用 `@cache` 做记忆化，避免重复计算。

**复杂度分析**

- 时间复杂度：$O(n \times amount)$，状态数 $O(n \times amount)$，每个状态 $O(1)$ 转移
- 空间复杂度：$O(n \times amount)$，递归栈与缓存

**Python3**

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        @cache
        def dfs(i, s):
            if i < 0:
                return 0 if s == 0 else inf
            if coins[i] > s:
                return dfs(i - 1, s)
            return min(dfs(i - 1, s), 1 + dfs(i, s - coins[i]))
        ans = dfs(len(coins) - 1, amount)
        return ans if ans < inf else -1
```

### 2.2 动态规划

与 2.1 等价的自顶向下记忆化实现，本质是同一套状态与转移。

**Python3**

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        f = [0] + [inf] * amount

        for x in coins:
            for i in range(x, amount + 1):
                f[i] = min(f[i], f[i - x] + 1)
        return f[amount] if f[amount] < inf else -1
```