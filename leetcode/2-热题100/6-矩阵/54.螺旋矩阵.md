# [54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/)

> **日期:** 2025-09-21
> **所用时间:** 20min

## 1.朴素做法

### 思路分析
本题要求按照螺旋顺序遍历矩阵，即从矩阵的左上角开始，按照从左到右、从上到下、从右到左、从下到上的顺序依次访问矩阵中的元素。我们可以通过模拟这个螺旋遍历的过程来实现。

### 具体做法
1. **初始化参数**：定义四个边界 `ln`（左边界）、`lm`（上边界）、`n`（下边界）、`m`（右边界），用于控制遍历的范围。同时，定义方向数组 `dirs` 或 `dx, dy` 来表示四个方向（右、下、左、上）。
2. **循环遍历**：使用一个循环不断访问矩阵元素，直到遍历完所有元素。在每次访问元素后，尝试按照当前方向移动到下一个位置。
3. **边界判断**：如果移动后的位置超出了当前边界，则回退到上一个位置，调整边界，并改变方向，然后继续移动。
4. **返回结果**：当遍历完所有元素后，返回存储结果的列表。

### 复杂度分析
- **时间复杂度**：$O(n)$，其中 $n$ 是矩阵中元素的总数。因为我们需要遍历矩阵中的每个元素一次。
- **空间复杂度**：$O(1)$，除了存储结果的列表外，只使用了常数级的额外空间。

**Python3**

```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        ans = []
        n, m = len(matrix), len(matrix[0])
        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        x = y = dir = ln = lm = 0
        cnt = n * m

        while len(ans) < cnt:
            ans.append(matrix[x][y])

            dx, dy = dirs[dir]
            x, y = dx + x, dy + y

            if x < ln or x >= n or y < lm or y >= m:
                x, y = x - dx, y - dy
                if dir == 0:
                    ln += 1
                elif dir == 1:
                    m -= 1
                elif dir == 2:
                    n -= 1
                else:
                    lm += 1
                dir = (dir + 1) % 4

                dx, dy = dirs[dir]
                x, y = dx + x, dy + y
            
        return ans
```

**C++**

```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        vector<int> ans;
        int n = matrix.size(), m = matrix[0].size(), cnt = n * m;

        int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}, dir = 0;
        int x = 0, y = 0, ln = 0, lm = 0;
        while (ans.size() < cnt)
        {
            ans.push_back(matrix[x][y]);
            x += dx[dir], y += dy[dir];
            
            if (x < ln || x > n - 1 || y < lm || y > m - 1)
            {
                x -= dx[dir], y -= dy[dir];

                if (dir == 0) ln ++;
                else if (dir == 1) m --;
                else if (dir == 2) n --;
                else lm ++;

                dir = (dir + 1) % 4;
                x += dx[dir], y += dy[dir];
            }
        }
        return ans;
    }
};
```