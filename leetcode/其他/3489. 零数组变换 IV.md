# [3489. 零数组变换 IV](https://leetcode.cn/problems/zero-array-transformation-iv/description/)

> **日期**：2025-06-10  
> **所用时间**：10min  
> **知识点**：动态规划、子集和、0-1 背包

## 1. 题目描述

给定一个整数数组 `nums` 和一个二维数组 `queries`，其中每个查询 `[l, r, val]` 表示可以选择区间 `[l, r]` 内的任意子集下标，将这些下标对应的值减去 `val`。求将所有元素变为 0 所需的最少查询次数 `k`，若不可能则返回 -1。

**示例 1：**

```
输入：nums = [3, 2, 1], queries = [[0, 2, 1], [0, 1, 2]]
输出：2
解释：
- 第 1 次操作选择 [0,1,2] 下标的全部，使得 nums = [2, 1, 0]
- 第 2 次操作选择 [0,1]，再各减 2（只影响下标 0），nums = [0, 1, 0]
- 由于 nums[1]=1 还需要操作一次，但无合适区间，所以最少共用 2 次
```

**示例 2：**

```
输入：nums = [1, 2, 3], queries = [[0, 2, 2]]
输出：-1
解释：
- 唯一一次操作不能把所有元素变成 0。
```

## 2. 解题算法

思路：每个下标可以独立选择是否应用覆盖它的每个查询，因此问题转化为：对于每个元素，其值能否表示为覆盖它的查询值的子集和。

1. 对每个下标 `i`，若 `nums[i] = 0` 则跳过
2. 收集所有覆盖下标 `i` 的查询（即 `l <= i <= r`）
3. 使用 0-1 背包思想：`f[j]` 表示能否用已考虑的查询值凑出和 `j`
4. 按查询顺序遍历，对每个覆盖 `i` 的查询更新 DP：`f[j] |= f[j - val]`
5. 当 `f[nums[i]]]` 为真时，记录所需查询数 `k + 1`，取所有下标的最大值
6. 若任一元素无法变为 0，返回 -1

复杂度分析：
- 时间复杂度：$O(n \times q \times V)$，其中 $n$ 为数组长度，$q$ 为查询数，$V$ 为元素值上界（最大约 1000）
- 空间复杂度：$O(V)$

**Python3**

```python
class Solution:
    def minZeroArray(self, nums: List[int], queries: List[List[int]]) -> int:
        ans = 0
        for i, x in enumerate(nums):
            if x == 0:
                continue
            
            f = [True] + [False] * x
            for k, (l, r, val) in enumerate(queries):
                if i < l or i > r:
                    continue
                for j in range(x, val - 1, -1):
                    f[j] |= f[j - val]
                if f[x]:
                    ans = max(ans, k + 1)
                    break
            else:
                return -1
        return ans
```
