# [3685. 含上限元素的子序列和](https://leetcode.cn/problems/subsequence-sum-with-maximum-possible-score/description/)

> **日期**：2026-02-05  
> **所用时间**：10min  
> **知识点**：动态规划

## 1. 题目描述

给定一个整数数组 `nums` 和一个二维数组 `queries`，其中每个查询 `[l, r, val]` 表示可以选择区间 `[l, r]` 内的任意子集下标，将这些下标对应的值减去 `val`。求将所有元素变为 0 所需的最少查询次数 `k`，若不可能则返回 -1。

**示例 1：**

```
输入：nums = [3, 2, 1], queries = [[0, 2, 1], [0, 1, 2]]
输出：2
解释：
- 第 1 次操作选择 [0,1,2] 下标的全部，使得 nums = [2, 1, 0]
- 第 2 次操作选择 [0,1]，再各减 2（只影响下标 0），nums = [0, 1, 0]
- 由于 nums[1]=1 还需要操作一次，但无合适区间，所以最少共用 2 次
```

**示例 2：**

```
输入：nums = [1, 2, 3], queries = [[0, 2, 2]]
输出：-1
解释：
- 唯一一次操作不能把所有元素变成 0。
```

## 2. 解题算法

思路：每个下标可以独立选择是否应用覆盖它的每个查询，因此问题转化为：对于每个元素，其值能否表示为覆盖它的查询值的子集和。

1. 对每个下标 `i`，若 `nums[i] = 0` 则跳过
2. 收集所有覆盖下标 `i` 的查询（即 `l <= i <= r`）
3. 使用 0-1 背包思想：`f[j]` 表示能否用已考虑的查询值凑出和 `j`
4. 按查询顺序遍历，对每个覆盖 `i` 的查询更新 DP：`f[j] |= f[j - val]`
5. 当 `f[nums[i]]]` 为真时，记录所需查询数 `k + 1`，取所有下标的最大值
6. 若任一元素无法变为 0，返回 -1

复杂度分析：
- 时间复杂度：$O(n \times q \times V)$，其中 $n$ 为数组长度，$q$ 为查询数，$V$ 为元素值上界（最大约 1000）
- 空间复杂度：$O(V)$

**Python3**

```python
class Solution:
    def subsequenceSumAfterCapping(self, nums: List[int], k: int) -> List[bool]:
        n = len(nums)
        nums.sort()
        ans = [False] * n
        f = [True] + [False] * k

        i = 0
        for x in range(1, n + 1):
            while i < n and nums[i] == x:
                for j in range(k, x - 1, -1):
                    f[j] |= f[j - x]
                i += 1
            
            for j in range(min(n - i, k // x) + 1):
                if f[k - j * x]:
                    ans[x - 1] = True
                    break
        return ans
```
