# [3628. 插入一个字母的最大子序列数](https://leetcode.cn/problems/maximum-subsequence-score-after-applying-operations/description/)

> **日期**：2026-02-26  
> **所用时间**：20min  
> **知识点**：动态规划

## 1. 题目描述

给定一个仅由字符 `'L'`、`'C'`、`'T'` 组成的字符串 `s`。你可以在 `s` 的**任意位置**（包括首尾）**插入**恰好一个字符（也只能是 `'L'`、`'C'` 或 `'T'`）。

插入后，得到一个新字符串。请计算新字符串中等于 **"LCT"** 的**不同子序列**的个数，并返回在所有插入方案中，该个数的**最大值**。

**说明**：子序列不要求连续，只要相对顺序与 "LCT" 相同即算一种。两个子序列若取的下标集合不同则视为不同。

**示例 1：**

- **输入**：s = "LCT"
- **输出**：2
- **解释**：原串已有 1 个 "LCT"。插入一个字符后，例如在 'L' 与 'C' 之间插入 'C' 得到 "L C C T"，可形成更多 "LCT" 子序列，最大为 2（或其他方案，以题目为准）。

**示例 2：**

- **输入**：s = "LTT"
- **输出**：1
- **解释**：原串中 "LCT" 子序列数为 0。插入 'C' 在合适位置后可得到 1 个 "LCT"。

**提示：**

- `1 <= s.length <= 10^5`
- `s` 仅包含 `'L'`、`'C'`、`'T'`

## 2. 动态规划

原串的 "LCT" 不同子序列数用经典 DP：`f[i][j]` 表示用 `s[0..i-1]` 形成 `t[0..j-1]`（其中 `t = "LCT"`）的方案数，转移为「不选 s[i]」或「选 s[i] 匹配 t[j]」（当 `s[i]==t[j]` 时）。则原串答案为 `numDistinct(s, "LCT")`。

插入一个字符后，最大值 = 原串 "LCT" 数 + 插入带来的最大增益：

1. **插入 'C'**：在某个位置插入 'C'，该位置左侧的每个 'L' 与右侧的每个 'T' 都能与这个 'C' 组成新的 "LCT"，增益为左侧 L 的个数 × 右侧 T 的个数。枚举插入位置，取 `max(cnt_l * cnt_t)` 即为插入 'C' 的最大增益。
2. **插入 'L'**：新 'L' 可与原串中的 "CT" 子序列组成 "LCT"，增益最多为原串中 "CT" 的不同子序列数，即 `numDistinct(s, "CT")`。
3. **插入 'T'**：新 'T' 可与原串中的 "LC" 子序列组成 "LCT"，增益最多为 `numDistinct(s, "LC")`。

因此答案为：`numDistinct(s, "LCT") + max( max_pos(cnt_l * cnt_t), numDistinct(s, "LC"), numDistinct(s, "CT") )`。

复杂度分析：

- 时间复杂度：$O(n \cdot |t|)$，其中 $n = |s|$，$|t| = 3$，即 $O(n)$；扫描求 `cnt_l`、`cnt_t` 为 $O(n)$。
- 空间复杂度：$O(n \cdot |t|)$，即 $O(n)$（可滚动数组优化为 $O(|t|)$）。

**Python3**

```python
class Solution:
    def numOfSubsequences(self, s: str) -> int:
        def numDistinct(s: str, t: str) -> int:
            n, m = len(s), len(t)
            f = [[1] + [0] * m for _ in range(n + 1)]

            for i, c1 in enumerate(s):
                for j, c2 in enumerate(t):
                    if c1 != c2:
                        f[i + 1][j + 1] = f[i][j + 1]
                    else:
                        f[i + 1][j + 1] = f[i][j + 1] + f[i][j]
            return f[n][m]
        
        cnt_t = s.count('T')
        cnt_l = 0
        res = 0
        for c in s:
            if c == 'T':
                cnt_t -= 1
            if c == 'L':
                cnt_l += 1
            res = max(res, cnt_l * cnt_t)
        return numDistinct(s, "LCT") + max(res, numDistinct(s, "LC"), numDistinct(s, "CT"))
```