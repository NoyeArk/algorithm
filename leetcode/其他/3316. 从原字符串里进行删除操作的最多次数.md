# [3316. 从原字符串里进行删除操作的最多次数](https://leetcode.cn/problems/find-maximum-removals-from-source-string/description/)

> **日期**：2025-06-10
> **所用时间**：10min

## 1. 记忆化搜索

思路:
1. 使用记忆化搜索解决这个问题。定义状态 $dfs(i, j)$ 表示考虑原字符串前 $i$ 个字符和模式串前 $j$ 个字符时，能够删除的最大次数。

2. 状态转移分析:
   - 如果 $i < j$，说明原字符串剩余长度小于模式串剩余长度，无法匹配，返回负无穷
   - 如果 $i < 0$，说明原字符串已经处理完，返回 0
   - 如果 $j < 0$ 或当前字符不匹配，只能删除当前字符（如果它在目标索引中）
   - 如果当前字符匹配，可以选择匹配或删除当前字符

3. 具体转移方程:
   - 当 $source[i] \neq pattern[j]$ 时：$dfs(i, j) = dfs(i-1, j) + (i \in targetIndices)$
   - 当 $source[i] = pattern[j]$ 时：$dfs(i, j) = \max(dfs(i-1, j-1), dfs(i-1, j) + (i \in targetIndices))$

- 时间复杂度: $O(n \times m)$
- 空间复杂度: $O(n \times m)$

**Python3**

```python
class Solution:
    def maxRemovals(self, source: str, pattern: str, targetIndices: List[int]) -> int:
        targetIndices = set(targetIndices)
        @cache
        def dfs(i, j):
            if i < j:
                return -inf
            if i < 0:
                return 0
            if j < 0 or source[i] != pattern[j]:
                return dfs(i - 1, j) + (i in targetIndices)
            return max(dfs(i - 1, j - 1), dfs(i - 1, j) + (i in targetIndices))
        ans = dfs(len(source) - 1, len(pattern) - 1)
        dfs.cache_clear()
        return ans
```

## 2. 转化为递推

状态定义: `f[i][j]` 表示考虑原字符串前 $i$ 个字符和模式串前 $j$ 个字符时，能够删除的最大次数。

状态转移:

- 如果 $i < j$，说明原字符串剩余长度小于模式串剩余长度，无法匹配，返回负无穷
- 如果 $i < 0$，说明原字符串已经处理完，返回 0
- 如果 $j < 0$ 或当前字符不匹配，只能删除当前字符（如果它在目标索引中）
- 如果当前字符匹配，可以选择匹配或删除当前字符，取两种情况的最大值

边界条件:
- 如果 $i < 0$ 且 $j < 0$，说明原字符串和模式串都处理完，返回 0
- 如果 $i < 0$ 且 $j \geq 0$，说明原字符串已经处理完，返回 0
- 如果 $i \geq 0$ 且 $j < 0$，说明模式串已经处理完，返回 0
- 如果 $i \geq 0$ 且 $j \geq 0$ 且当前字符不匹配，只能删除当前字符（如果它在目标索引中）
- 如果 $i \geq 0$ 且 $j \geq 0$ 且当前字符匹配，可以选择匹配或删除当前字符，取两种情况的最大值

最终答案: `f[len(source)][len(pattern)]` 。

复杂度分析:

- 时间复杂度: $O(n \times m)$
- 空间复杂度: $O(n \times m)$

**Python3**

```python
class Solution:
    def maxRemovals(self, s: str, t: str, targetIndices: List[int]) -> int:
        targetIndices = set(targetIndices)
        n, m = len(s), len(t)
        f = [[-inf] * (m + 1) for _ in range(n + 1)]
        f[0][0] = 0

        for i in range(n):
            is_del = int(i in targetIndices)
            f[i + 1][0] = f[i][0] + is_del
            for j in range(min(i + 1, m)):
                f[i + 1][j + 1] = f[i][j + 1] + is_del
                if s[i] == t[j]:
                    f[i + 1][j + 1] = max(f[i + 1][j + 1], f[i][j])
        return f[n][m]
```