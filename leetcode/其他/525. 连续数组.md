# [525. 连续数组](https://leetcode.cn/problems/contiguous-array/)

> **日期**：2025-02-11  
> **所用时间**：2min  
> **知识点**：前缀和、哈希表

## 1. 题目描述

给定一个二进制数组 `nums`，找出含有相同数量的 `0` 和 `1` 的最长连续子数组，并返回该子数组的长度。

**示例 1：**

```
输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
```

**示例 2：**

```
输入: nums = [0,1,0]
输出: 2
说明: [0, 1] 或 [1, 0] 是具有相同数量 0 和 1 的最长连续子数组。
```

**提示：**

- `1 <= nums.length <= 10^5`
- `nums[i]` 不是 `0` 就是 `1`

## 2. 实际使用的算法：前缀和 + 哈希表

将 `0` 视为 `-1`，则「相同数量的 0 和 1」等价于子数组和为 0。对数组做前缀和 `s[0]=0, s[i]=s[i-1]+(nums[i]==1?1:-1)`。若 `s[i]=s[j]`（i>j），则区间 `[j+1,i]` 的和为 0，长度为 `i-j`。用哈希表记录每个前缀和**第一次**出现的下标，从左到右枚举右端点，若当前前缀和已出现过则用「当前下标 - 第一次下标」更新答案。

- **时间复杂度**：$O(n)$
- **空间复杂度**：$O(n)$

**Python3**

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        nums = [1 if x else -1 for x in nums]
        s = list(accumulate(nums, initial=0))

        pos = {}
        ans = 0
        for i, x in enumerate(s):
            if x in pos:
                ans = max(ans, i - pos[x])
            else:
                pos[x] = i
        return ans
```

优化：

```python
class Solution:
    def findMaxLength(self, nums: List[int]) -> int:
        pos = {0: -1}
        ans = s = 0
        for i, x in enumerate(nums):
            s += 1 if nums[i] else -1
            if s in pos:
                ans = max(ans, i - pos[s])
            else:
                pos[s] = i
        return ans
```