# 01背包

01背包问题是最基础的背包问题。给定 $n$ 个物品,每个物品有重量 $w[i]$ 和价值 $v[i]$。现有一个容量为 $C$ 的背包，每个物品最多只能选一次，求解将哪些物品装入背包可使价值总和最大。

## 1. 状态定义

定义 $dp[i][j]$ 表示从前 $i$ 个物品中选择，总重量不超过 $j$ 的情况下能获得的最大价值。

## 2. 状态转移方程

对于第 $i$ 个物品，有两种选择：
- 不选择第 $i$ 个物品: $dp[i][j] = dp[i-1][j]$
- 选择第 $i$ 个物品: $dp[i][j] = dp[i-1][j-w[i]] + v[i]$

因此状态转移方程为：

$$
dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + v[i])  (j ≥ w[i])
$$

$$
dp[i][j] = dp[i-1][j]                                (j < w[i])
$$

## 3. 初始化

- $dp[0][j] = 0$：没有物品时，最大价值为0
- $dp[i][0] = 0$：背包容量为0时，最大价值为0

## 4. 计算顺序

从前往后遍历物品，对每个物品从大到小遍历背包容量。

## 5. 代码

- 时间复杂度: $O(n \times C)$
- 空间复杂度: $O(n \times C)$

**Python3**

```python
def knapsack(n: int, C: int, w: list[int], v: list[int]) -> int:
    dp = [[0] * (C + 1) for _ in range(n + 1)]

    # 遍历每个物品
    for i in range(1, n + 1):
        # 遍历背包容量
        for j in range(C + 1):
            # 不选择第i个物品
            dp[i][j] = dp[i - 1][j]
            # 选择第i个物品
            if j >= w[i - 1]:
                dp[i][j] = max(dp[i][j], dp[i - 1][j - w[i - 1]] + v[i - 1])
                
    return dp[n][C]
```

### 空间优化

由于每个状态只依赖于上一行的状态，因此可以使用滚动数组优化空间复杂度。

具体来说:
1. 将二维数组压缩为一维数组 `dp[j]`，表示容量为 j 的背包能装下的最大价值
2. 对于每个物品 i，从后往前遍历背包容量 j
3. 状态转移方程变为: `dp[j] = max(dp[j], dp[j-w[i]] + v[i])`

为什么要从后往前遍历?
- 因为当前状态依赖于上一行左边的状态
- 如果从前往后遍历，会导致上一行的状态被覆盖，从而影响后续计算
- 从后往前遍历可以保证计算 dp[j] 时，dp[j-w[i]] 还是上一行的状态

空间复杂度从 $O(N×C)$ 优化到 $O(C)$。

**Python3**

```python
def knapsack_opt(n: int, C: int, w: list[int], v: list[int]) -> int:
    dp = [0] * (C + 1)
    
    for i in range(n):
        for j in range(C, w[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - w[i]] + v[i])
            
    return dp[C]
```